\documentclass[12pt, titlepage]{article}


% Author's up-front packages
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{longtable}

%Packages from template
\usepackage{amsmath, mathtools}
%\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr-hyper}
\usepackage{hyperref}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

% Author's packages

\usepackage{cite}
\usepackage{indentfirst}
\usepackage{csquotes}
\usepackage{cleveref}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\input{../../Comments}

\newcommand{\progname}{STEM Moir{\'e} GPA}
\externaldocument[SRS:]{../../SRS/SRS}
\externaldocument[TP:]{../../TestPlan/TestPlan}
\externaldocument[MG:]{../MG/MG}

%Set the custom referencing syste
	% Module
\newtheorem{M}{M}
\crefname{M}{M}{Ms}
	% Module Interface Specification
\newtheorem{MIS}{MIS}
\crefname{MIS}{MIS}{MISs}
	% Requirements
\newtheorem{R}{R}
\crefname{R}{R}{Rs}
	% Instance Model
\newtheorem{IM}{IM}
\crefname{IM}{IM}{IMs}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{Alexandre Pofelski \\
		macid: pofelska \\
		github: slimpotatoes}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
27/11/2017 & 1.0 & MIS First draft \\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

The same Symbols, Abbreviations and Acronyms as in the SRS, the TestPlan and the MG (available in \href{https://github.com/slimpotatoes/STEM_Moire_GPA}{\progname{}} repository) are used in the Module Interface Specifications document. 

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for \progname{}. The full documentation and implementation can be found in \href{https://github.com/slimpotatoes/STEM_Moire_GPA}{\progname{}} repository.

\section{Notation}

The structure of the MIS for modules comes from \cite{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}. The following table summarizes the primitive data types used by \progname.

\iffalse
The mathematical notation comes from Chapter 3 of
\cite{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.
\fi

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & an integer number \\
natural & $\mathbb{N}$ & a natural number \\
real & $\mathbb{R}$ & a real number \\
complex & $\mathbb{C}$ & a complex number \\
image space & $\mathbb{I}$ & subset of $\mathbb{N}^2$ such that $\mathbb{I}=\{(x,y)\in \mathbb{N} \times \mathbb{N} : 0 \leq x \leq N-1 \wedge 0 \leq y \leq N-1 \} $ with $N \in \mathbb{N}$ representing the number of pixels of the image\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname{} uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[H]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding Module} & ~ \\
\midrule

\multirow{9}{0.3\textwidth}{Behaviour-Hiding Module} 
& \progname{} Control (\cref{MG:M_Control}, \cref{MIS_Control})\\
& \progname{} GUI (\cref{MG:M_GUISMG}, \cref{MIS_GUISMG})\\
& Input (\cref{MG:M_InputFormat}, \cref{MIS_Input})\\
& SMH simulation (\cref{MG:M_SMHSim}, \cref{MIS_SMHSim})\\
& GPA (\cref{MG:M_GPA}, \cref{MIS_GPA})\\
& Mask (\cref{MG:M_Mask}, \cref{MIS_Mask})\\
& Unstrained region (\cref{MG:M_URef}, \cref{MIS_URef})\\
& Conversion (\cref{MG:M_MtoCConv}, \cref{MIS_MtoCConv})\\
& 2D strain tensor (\cref{MG:M_StrainCalc}, \cref{MIS_StrainCalc})\\
\midrule

\multirow{6}{0.3\textwidth}{Software Decision Module} & Fourier Transform (\cref{MG:M_FT}, \cref{MIS_FT}) \\
& Gradient (\cref{MG:M_Gradient}, \cref{MIS_Gradient}) \\
& Least square fitting method (\cref{MG:M_LSFM}, \cref{MIS_LSFM})  \\
& Phase Operation (\cref{MG:M_Phase}, \cref{MIS_Phase}) \\
& Data structure (\cref{MG:M_DataStruct}, \cref{MIS_DataStruct}) \\
& Generic GUI/Plot (\cref{MG:M_GUIGene}, \cref{MIS_GUIGene}) \\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage


\section{MIS of STEM Moir{\'e} GPA Control Module (\texorpdfstring{\cref{MG:M_Control}}))} \label{MIS_Control}

\subsection{Module}
main
\subsection{Uses}
\begin{itemize}
\item STEM Moir{\'e} GPA GUI (\cref{MG:M_GUISMG}, \cref{MIS_GUISMG})
\item Processing modules \begin{itemize}
	\item Unstrained region (\cref{MG:M_URef}, \cref{MIS_URef})
	\item Conversion (\cref{MG:M_MtoCConv}, \cref{MIS_MtoCConv})
	\item SMH Simulation (\cref{MG:M_SMHSim}, \cref{MIS_SMHSim})
	\item GPA(\cref{MG:M_GPA}, \cref{MIS_GPA})
	\item 2D Strain Tensors (\cref{MG:M_StrainCalc}, \cref{MIS_StrainCalc})
\end{itemize}
\item Input (\cref{MG:M_InputFormat}, \cref{MIS_Input})
\item Data Structure (\cref{MG:M_DataStruct}, \cref{MIS_DataStruct})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
main & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\progname{} is designed to have the process flow driven by user directly through GUI{\_}SMG. The STEM Moir{\'e} GPA Control Module uses the events in STEM Moi{\'e} GPA GUI to use the processing modules in the order defined by the user.

\subsubsection{State Variables}

None

\subsubsection{Access Routine Semantics}

\noindent main():
\begin{itemize}
\item transition:

GUIFlow()
\noindent\textit{{\#} Software permanently running until user abort it by closing the GUI} \medskip
GUI{\_}Conv()
\noindent\textit{{\#} Open the entry field GUI for the conversion process} \medskip

If one of the event below is triggered by the user, an action is performed by \progname{}. The possible events are :
	\begin{itemize}
	\item $(\text{event{\_}Input()} \\ \rightarrow \text{Get the path pathISMH and pathIC from the user} \  \rightarrow \\ \text{load{\_}files(pathISMH,pathIC)})\rightarrow \text{GUI{\_}SMHexp}())$
	\item $(\text{event{\_}SimSMH()} \rightarrow \\ \text{SMHsim}(\text{load(ISMHexp)},\text{load(ICref)}, \text{load(pISMHexp)},\text{load(pICref)} \\ \rightarrow \text{GUI{\_}SMHsim}())$
	\item $\text{For each GUI object mask } M_j \text{ with } j=\{1,2\} \\ \text{ drawn by the user in the of GUI{\_}SMHsim() window }: $
		\begin{enumerate}
		\item $(\text{event{\_}GPA()} \rightarrow  \text{gpa}(\text{load(FTISMHexp)},\text{collect{\_}circ}(M_j),\text{id}(M_j)) \\ \rightarrow \text{GUI{\_}Phase}())$
		\item $(\text{event{\_}URef()} \rightarrow \\ \text{ZeroStrain}(\text{load{\_}g}(\text{id}(M_j))(\text{deltagM}),\text{load{\_}g}(\text{id}(M_j))(\text{gMuns}),\\ \text{collect{\_}rect}(U),\text{id}(M_j))\rightarrow \text{update GUI{\_}Phase}())$
		\item $(\text{event{\_}Conversion()} \rightarrow \text{Read the $n$ and $m$ entry fields in GUI{\_}Conv} \rightarrow \\ \text{conversion}(\text{load{\_}g}(\text{id}(M_j))(\text{pISMHexp}),\text{load{\_}g}(\text{id}(M_j)(\text{gMuns})),\text{id}(M_j))$
		\end{enumerate}
	\item $(\text{event{\_}StrainCalc()} \rightarrow \\
	 \text{CalcStrain}(\text{load}(\text{id}(M_1),\text{gCuns}),\text{load}(\text{id}(M_2),\text{gCuns}),\text{load}(\text{id}(M_1),\text{deltagM}),\\ \text{load}(\text{id}(M_2),\text{deltagM})) \rightarrow \text{GUI{\_}Strain}())$
	\end{itemize}
\end{itemize}

\section{MIS of STEM Moir{\'e} GPA GUI Module (\texorpdfstring{\cref{MG:M_GUISMG}}))} \label{MIS_GUISMG}

\noindent\textit{{\#} Specific GUI module to respect the requirements from the SRS}\medskip

\subsection{Module}
GUI{\_}SMG
\subsection{Uses}
\begin{itemize}
\item Generic GUI/Plot (\cref{MG:M_GUIGene}, \cref{MIS_GUIGene})
\item Data Structure (\cref{MG:M_DataStruct}, \cref{MIS_DataStruct})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\noindent\textit{{\#} For the moment, the GUI exceptions are not mentioned to cover the other aspects of \progname{}}\medskip

\begin{center}
\begin{tabular}{p{4cm} p{2cm} p{2cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
GUIFlow & - & - & - \\
GUI{\_}SMHexp & - & - & - \\
GUI{\_}SMHSim & - & - & - \\
GUI{\_}Phase & - & - & - \\
GUI{\_}Conv & - & - & - \\
GUI{\_}Strain & - & - & - \\
event{\_}Input & - & - & - \\
event{\_}SMHSim & - & - & - \\
event{\_}GPA & - & - & - \\
event{\_}URef & - & - & - \\
event{\_}StrainCalc & - & - & - \\
collect{\_}circ & GUI object & object & - \\
collect{\_}rect & GUI object & object & -\\
id & GUI object & object & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\progname{} process flow is driven by user through GUI{\_}SMG. User triggers the events that start the selected processing step. 

\subsubsection{State Variables}
None

\subsubsection{Environment Variables}

\noindent Win{\_}Flow: GUI object\\
Win{\_}SMHexp: GUI object\\
Win{\_}SMHSim: GUI object\\
Win{\_}Phase: GUI object\\
Win{\_}FTSMH: GUI object\\
Win{\_}Conv: GUI object\\
Win{\_}Deltag: GUI object\\
Win{\_}Strain: GUI object\\
button{\_}Input: GUI object\\
button{\_}SMHSim: GUI object\\
button{\_}GPA: GUI object\\
button{\_}URef: GUI object\\
button{\_}StrainCalc: GUI object\\


\subsubsection{Access Routine Semantics}

\noindent\textit{{\#} GUI embedding the process flow into buttons triggering events. It is the user role to execute the process flow}\medskip

\noindent GUIFlow():
\begin{itemize}
\item transition: 
	\begin{enumerate}
	\item Win{\_}Flow=fig('Win{\_}Flow') 
	\item button(Win{\_}Flow,5,'Input','SMHSim','GPA','URef','StrainCalc') 
	\item plot()
	\end{enumerate} 
\end{itemize}
\bigskip

\noindent\textit{{\#} Events triggered by each button pressed by the user}\medskip

\noindent event{\_}Input():
\begin{itemize}
\item transition: Trigger event{\_}Input when button{\_}Input pressed
\end{itemize}
\bigskip
\noindent event{\_}SMHSim():
\begin{itemize}
\item transition: Trigger event{\_}SMHSim when button{\_}SMHSim pressed
\end{itemize}
\bigskip
\noindent event{\_}GPA():
\begin{itemize}
\item transition: Trigger event{\_}GPA when button{\_}GPA pressed
\end{itemize}
\bigskip
\noindent event{\_}URef():
\begin{itemize}
\item transition: Trigger event{\_}URef when button{\_}URef pressed
\end{itemize}
\bigskip
\noindent event{\_}StrainCalc():
\begin{itemize}
\item transition: Trigger event{\_}StrainCalc when button{\_}StrainCalc press
\end{itemize}
\bigskip

\noindent\textit{{\#} GUI to display the display the input files $I_{\mathit{SMH}_{\text{exp}}}$, $I_{C_{\text{ref}}}$}\medskip

\noindent GUI{\_}SMHexp():
\begin{itemize}
\item transition: 
	\begin{enumerate}
	\item Win{\_}SMHexp=fig('Win{\_}SMHexp',load($I_{\mathit{SMH}_{\text{exp}}}$), load($I_{C_{\text{ref}}}$))
	\item plot()
	\end{enumerate} 
\end{itemize}
\bigskip


\noindent\textit{{\#} GUI to display the simulation of the STEM Moir{\'e} hologram using the reference image and to let the user input $M$ (from \cref{SRS:R_4}, \cref{SRS:R_5})}\medskip

\noindent GUI{\_}SMHSim():
\begin{itemize}
\item transition: 
	\begin{enumerate}
	\item Win{\_}SMHSim=fig('Win{\_}SMHSim',load(FTISMHexp),load(FTISMHsim),circle($M$))
	\item plot()
	\end{enumerate} 
\end{itemize}
\bigskip

\noindent\textit{{\#} GUI to display the phase resulting from the GPA algorithm and to let the user input $U$ (from \cref{SRS:R_8})}\medskip

\noindent GUI{\_}Phase($id$):
\begin{itemize}
\item transition: 
	\begin{enumerate}
	\item Win{\_}Phase=fig('Win{\_}Phase',load{\_}g($id$)(PhasegM),rectangle($U$))
	\item Win{\_}Deltag=fig('Win{\_}Deltag',load{\_}g($id$)(deltagM))
	\item plot()
	\end{enumerate} 
\end{itemize}
\bigskip

\noindent\textit{{\#} GUI to display the window to let the user input $n$ and $m$ (from \cref{SRS:R_11})}\medskip

\noindent GUI{\_}Conv():
\begin{itemize}
\item transition: 
	\begin{enumerate}
	\item Win{\_}Conv=fig('Win{\_}Conv',entry{\_}field($n$),entry{\_}field($m$))
	\item plot()
	\end{enumerate} 
\end{itemize}
\bigskip

\noindent\textit{{\#} GUI to display the window showing the final strain maps (from \cref{SRS:R_14})}\medskip

\noindent GUI{\_}Strain():
\begin{itemize}
\item transition: 
	\begin{enumerate}
	\item Win{\_}Strain=fig('Win{\_}Strain',load(Exx),load(Eyy),load(Exy),load(Rxx))
	\item plot()
	\end{enumerate} 
\end{itemize}
\bigskip


\noindent\textit{{\#} Reader of the GUI objects drawn by the user (circle $M$ or rectangle $U$)} \medskip

\noindent collect{\_}circ($A$)
\begin{itemize}
\item output: $C$ such that
	\begin{enumerate}
	\item Execute read{\_}user{\_}GUI($A$)
	\item Verify the type of the object read{\_}user{\_}GUI($A$) to match a circle
	\item Output $C$=$(x_c,y_c,R)$ with $(x_c,y_c)$ the coordinate (pixel number) of the center of the circle $A$ and $R$ the radius of the circle $A$.
	\end{enumerate} 
\end{itemize}
\bigskip

\noindent collect{\_}rect($A$)
\begin{itemize}
\item output: $S$ such that
	\begin{enumerate}
	\item Execute read{\_}user{\_}GUI($A$)
	\item Verify the type of the object read{\_}user{\_}GUI($A$) to match a rectangle
	\item Get the coordinate of the upper left corner $(x_0,y_0)$ and the coordinate of the bottom right corner $(x_1,y_1)$. 
	\item output $S=([x_0,x_1],[y_0,y_1])$
	\end{enumerate} 
\end{itemize}
\bigskip

\noindent\textit{{\#} Function to read the unique id of a GUI object} \medskip

\noindent id($A$)
\begin{itemize}
\item output: $B$ such that $B$ is the id part of the read{\_}user{\_}GUI($A$) output from the Generic GUI/Plot Module.
\end{itemize}
\bigskip

\section{MIS of Input Module (\texorpdfstring{\cref{MG:M_InputFormat}}))} \label{MIS_Input}

\subsection{Module}
Input
\subsection{Uses}
\begin{itemize}
\item STEM Moir{\'e} GPA GUI (\cref{MG:M_GUISMG}, \cref{MIS_GUISMG})
\item Data Structure (\cref{MG:M_DataStruct}, \cref{MIS_DataStruct})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{2cm} p{1cm} p{8cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
load{\_}files & string & - & badFilePath, badPixelP, badPixelPref, badIC, badISMH, badFileFormat \\
verifyM & - & - & NoMask, BadMask \\
verifyU & - & - & BadU, NoU \\
verifyMdiff & - & - & SameMask \\
verifyNM & - & - & BadNM\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

data : object

\iffalse
load{\_}mask & GUI object & - & NoMask \\
load{\_}U & GUI object & - & NoU \\
load{\_}nm & GUI object & - & NoConv \\
$I_{\mathit{SMH}_{\text{exp}}}$ & - & $f:\mathbb{N}^2\rightarrow\mathbb{R}$ & - \\
$p$ & - & $\mathbb{R}^{+*}$ & - \\
$I_{C_{\text{ref}}}$ & - & $f:\mathbb{N}^2\rightarrow\mathbb{R}$ & - \\
$p_{\text{ref}}$ & - & $\mathbb{R}^{+*}$ & - \\
$U$ & - & - & - \\
$M$ & - & $(x_c,y_c) \in \mathbb{R}^2$ , $R \in \mathbb{R}^{+*}$ & - \\
$n$ & - & $\mathbb{Z}$ & - \\
$m$ & - & $\mathbb{Z}$ & - \\

\noindent For \cref{SRS:R_1} and \cref{SRS:IM_1} in the SRS document,\\
\noindent$I_{\mathit{SMH}_{\text{exp}}}$ : $f:\mathbb{N}^2\rightarrow\mathbb{R}$ \\
$p$ : $\mathbb{R}^{+*}$\\
$I_{C_{\text{ref}}}$ : $f:\mathbb{N}^2\rightarrow\mathbb{R}$\\
$p_{\text{ref}}$ : $\mathbb{R}^{+*}$ \\

\noindent For \cref{SRS:R_5} and \cref{SRS:IM_2} in the SRS document,\\
\noindent$M$ : $(x_c,y_c) \in \mathbb{R}^2$ , $R \in \mathbb{R}^{+*}$\\

\noindent For \cref{SRS:R_8} and \cref{SRS:IM_3} in the SRS document,\\
\noindent$U$ :\\ 

\noindent For \cref{SRS:R_11} and For \cref{SRS:IM_4} in the SRS document,\\
\noindent$n$ : $\mathbb{Z}$\\
$m$ : $\mathbb{Z}$\\
\fi

\subsubsection{Access Routine Semantics}

\noindent\textit{{\#} Function to load $I_{\mathit{SMH}_{\text{exp}}}$, $I_{C_{\text{ref}}}$, $p$ and $p_{\text{ref}}$ and respect \cref{SRS:R_1} from the SRS.}
\medskip

\noindent load{\_}files(pathISMH,pathIC):
\begin{itemize}
\item transition: pathISMH and pathIC are the file paths for the input files. The following procedure is performed:
\begin{enumerate}
\item Verify the format of the files to be .dm3
\item The .dm3 files are read and their respective  metafiles are collected.
\item From the metafile, $I_{\mathit{SMH}_{\text{exp}}}$, $I_{C_{\text{ref}}}$, $p$ and $p_{\text{ref}}$ are extracted.
\item Verify $I_{\mathit{SMH}_{\text{exp}}}$, $I_{C_{\text{ref}}}$ to be 2D arrays of real numbers.
\item Verify  $p$ and $p_{\text{ref}}$ to be strictly positive
\item The variables $I_{\mathit{SMH}_{\text{exp}}}$, $I_{C_{\text{ref}}}$, $p$ and $p_{\text{ref}}$ are stored in the data structure:
\begin{itemize}
\item store(ISMHexp, $I_{\mathit{SMH}_{\text{exp}}}$)
\item store(pISMexp, $p$)
\item store(ICref, $I_{C_{\text{ref}}}$)
\item store(pICref, $p_{\text{ref}}$)
\end{itemize}
\end{enumerate}   
\item exception:
\noindent \begin{longtable*}[l]{l l} 
$\neg (p > 0)$ & $\Rightarrow$ badPixelP\\
$\neg (p_{\text{ref}} > 0)$ & $\Rightarrow$ badPixelP\\
($\exists \vec{r} \in \mathbb{I}, \ I_{\mathit{SMH}_{\text{exp}}}(\vec{r}) \notin \mathbb{R})$ & $\Rightarrow$ badISMH\\
($\exists \vec{r} \in \mathbb{I}, \ II_{C_{\text{ref}}}(\vec{r}) \notin \mathbb{R})$ & $\Rightarrow$ badIC\\
If the file targeted by pathISMH or pathIC doesn't exist & $\Rightarrow$ badFilePath\\
If the file format is not appropriate & $\Rightarrow$ badFileFormat\\
\end{longtable*}
\end{itemize}

\noindent\textit{{\#} Functions to verify the size of the unstrained reference input $U$ (see \cref{SRS:R_9}), the size of the mask input $M_j$ and if both masks are different (see \cref{SRS:R_6}).}
\medskip

\noindent verifyU($U$):
\begin{itemize}
\item transition: TO DO !!!
\item exception:\newline
$(U=\emptyset\Rightarrow\text{NoU})$\\
$(\text{image space of $U$}>\mathbb{I}\Rightarrow \text{BadU})$
\end{itemize}

\noindent verifyM($M_j$):
\begin{itemize}
\item transition: TO DO !!!
\item exception:\newline
$(M_j=\emptyset\Rightarrow\text{NoMask})$\\
Add something for bad Mj
\end{itemize}

\noindent verifyMdiff($M_1,M_2$):
\begin{itemize}
\item transition: TO DO !!!
\item exception:\newline
$(M_1=M_2\Rightarrow\text{SameMask})$
\end{itemize}

\noindent verifyMN($M_1,M_2$):
\begin{itemize}
\item transition: TO DO !!!
\item exception:\newline
\newline
$(\neg (n \in \mathbb{N} \wedge m \in \mathbb{N}) \Rightarrow \text{BadNM})$
\end{itemize}

\section{MIS of SMH Simulation (\texorpdfstring{\cref{MG:M_SMHSim}}))} \label{MIS_SMHSim}

\subsection{Module}
SMHSimCalc
\subsection{Uses}
\begin{itemize}
\item Fourier Transform (\cref{MG:M_FT}, \cref{MIS_FT})
\item Data Structure (\cref{MG:M_DataStruct}, \cref{MIS_DataStruct})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
SMHsim & $I_{\mathit{SMH}_{\text{exp}}}:\mathbb{I}\rightarrow\mathbb{R} $ $ I_{C_{\text{ref}}}:\mathbb{I}\rightarrow\mathbb{R}$ , $p \in \mathbb{R}^{+*}$ , $p_{\text{ref}} \in \mathbb{R}^{+*}$ & $\widetilde{I}_{\mathit{SMH}_{\text{exp}}}:\mathbb{I}\rightarrow\mathbb{C}$ $\widetilde{I}_{\mathit{SMH}_{\text{sim}}}:\mathbb{I}\rightarrow\mathbb{C}$ $N_{\text{lim}} \in \mathbb{N}^{*}$ & WarnNlimzero\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

data : object

\subsubsection{Access Routine Semantics}

\noindent SMHsim($I_{\mathit{SMH}_{\text{exp}}},I_{C_{\text{ref}}}, p, p_{\text{ref}}$):
\begin{itemize} 
\item transition:
	\begin{enumerate}
	\item store(FTISMHexp, $\widetilde{I}_{\mathit{SMH}_{\text{exp}}}$) such that
	\begin{equation*}
	\widetilde{I}_{\mathit{SMH}_{\text{exp}}}(\vec{\nu})=\mathcal{FT}[I_{\mathit{SMH}_{\text{exp}}}(\vec{r})]
	\end{equation*}
	\item store(FTISMHsim, $\widetilde{I}_{\mathit{SMH}_{\text{sim}}}$) such that
	\begin{equation*}
	\begin{gathered}
	\widetilde{I}_{\mathit{SMH}_{\text{sim}}}(\vec{\nu})=\frac{1}{p^2}\sum_{\vec{q}\in Q_{lim}}\mathcal{FT}[I_{C_{\text{ref}}}(\vec{\nu}-\frac{\vec{q}}{p})] \\
	\text{with } Q_{\text{lim}}=\{\forall (n,m) \in \mathbb{Z}^{2}\cap[-N_{\text{lim}},N_{\text{lim}}]^2, \ \vec{q}=n\vec{u_x}+m\vec{u_y}\} \\
	\text{and } N_{\text{lim}}=\Xi(\frac{p}{p_{\text{ref}}}) \text{ with } \Xi \text{ the floor function } 
	\end{gathered}
	\end{equation*}
	\end{enumerate}

\item exception:
\newline
$(N_{lim}=0 \Rightarrow \text{WarnNlimzero})$
\end{itemize}

\section{MIS of GPA Module (\texorpdfstring{\cref{MG:M_GPA}}))} \label{MIS_GPA}

\subsection{Module}
GPACalc
\subsection{Uses}
\begin{itemize}
\item Mask (\cref{MG:M_Mask}, \cref{MIS_Mask})
\item Fourier Transform (\cref{MG:M_FT}, \cref{MIS_FT})
\item Phase (\cref{MG:M_Phase}, \cref{MIS_Phase})
\item Gradient (\cref{MG:M_Gradient}, \cref{MIS_Gradient})
\item Data Structure (\cref{MG:M_DataStruct}, \cref{MIS_DataStruct})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
gpa & $\widetilde{I}_{\mathit{SMH}_{\text{exp}}}:\mathbb{I}\rightarrow\mathbb{C}$ , $M:\mathbb{N}^2\times\mathbb{R}^{+*}$ , $id : \text{id GUI object}$ & $P_{\vec{g}}:\mathbb{I}\rightarrow\mathbb{R}$ , $\overrightarrow{\Delta g}:\mathbb{I}\rightarrow\mathbb{R}^2$ , $P_{\Delta \vec{g}}:\mathbb{I}\rightarrow\mathbb{R}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

data : object

\subsubsection{Access Routine Semantics}

\noindent gpa($\widetilde{I}_{\mathit{SMH}_{\text{exp}}},M,id$):
\begin{itemize} 
\item transition: 
	\begin{enumerate}
	\item $M,\overrightarrow{g}^{M_{\text{exp}}}=\text{MCirc}(M)$
	\item store{\_}g($id$,gMuns,$\overrightarrow{g}^{M_{\text{exp}}}$)
	\item Calculate $P_{\vec{g}}$ such that
	\begin{equation*}
	\forall \vec{r} \in \mathbb{R}^2, \ P_{\vec{g}}(\vec{r})=\text{arg}(i\mathcal{FT}[M\times\widetilde{I}_{\mathit{SMH}_{\text{exp}}}])
	\end{equation*}
	\item store($id$,deltagM,$\overrightarrow{\Delta g}$) such that
	\begin{equation*}
	\forall \vec{r} \in \mathbb{R}^2, \ \Delta \overrightarrow{g}(\vec{r})=\frac{1}{2\pi}\text{grad}(\text{unwrap}(P_{\vec{g}}(\vec{r})))-\overrightarrow{g}^{M_{\text{exp}}}(\vec{r})
	\end{equation*}
	\item store($id$,PhasegM,$P_{\Delta \vec{g}}$) such that
	\begin{equation*}
	\forall \vec{r} \in \mathbb{R}^2, \ P_{\Delta \vec{g}}(\vec{r})=\text{wrap}(\text{unwrap}[P_{\vec{g}}(\vec{r})]-2\pi\overrightarrow{g}^{M_{\text{exp}}}(\vec{0})\cdot \vec{r})
	\end{equation*}
	\end{enumerate}
\item exception:
\end{itemize}

\section{MIS of Mask Module (\texorpdfstring{\cref{MG:M_Mask}}))} \label{MIS_Mask}

\subsection{Module}
Mask
\subsection{Uses}
None

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
MCirc & $(x_c,y_c) \in \mathbb{N}^2$ , $R \in \mathbb{R}^{+*}$ & $M:\mathbb{I}\rightarrow\mathbb{R}$, $\overrightarrow{g_0} :\mathbb{I}\rightarrow\mathbb{R}^2$ & BadRadius, BadCenter\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None

\subsubsection{Access Routine Semantics}

\noindent MCirc($x_c,y_c,R$):
\begin{itemize} 
\item output: $M$,$\overrightarrow{g_0}$
	\begin{itemize}
	\item $M$ such that
	\begin{equation*}
	\forall \vec{r} \in \mathbb{I}, \ M(x,y)=\begin{cases}
	1, \ (x-x_c)^2+(y-y_c)^2\leq R^2 \\
	0, \ (x-x_c)^2+(y-y_c)^2> R^2
	\end{cases}
	\end{equation*}
	\item $\overrightarrow{g_0}$ such that
	\begin{equation*}
	\forall \vec{r} \in \mathbb{I}, \ \overrightarrow{g_0}(\vec{r})=\begin{bmatrix}
	x_c\\
	y_c
	\end{bmatrix}
	\end{equation*}
	\end{itemize}
\item exception:
\newline
$(\neg R>0 \Rightarrow \text{BadRadius})$\\
$(\neg (x_c \in \mathbb{N} \wedge y_c \in \mathbb{N}) \Rightarrow \text{BadCenter})$
\end{itemize}

\section{MIS of Unstrained region Module (\texorpdfstring{\cref{MG:M_URef}}))} \label{MIS_URef}

\subsection{Module}
URefCalc
\subsection{Uses}
\begin{itemize}
\item Least Square Fit (\cref{MG:M_LSFM}, \cref{MIS_LSFM})
\item STEM Moir{\'e} GPA GUI (\cref{MG:M_GUISMG}, \cref{MIS_GUISMG})
\item Data Structure (\cref{MG:M_DataStruct}, \cref{MIS_DataStruct})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
ZeroStrain & $\overrightarrow{\Delta g}^M:\mathbb{I}\rightarrow\mathbb{R}^2$, $U \in \text{ subset of } \mathbb{I}$ , $\overrightarrow{g}^{M_{\text{exp}}}:\mathbb{I}\rightarrow\mathbb{R}^2$ , $id : \text{id GUI object}$  & $\overrightarrow{\Delta g}_{\text{cor}}^M:\mathbb{I}\rightarrow\mathbb{R}^2$ , $\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}:\mathbb{I}\rightarrow\mathbb{R}^2$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

data : object

\subsubsection{Access Routine Semantics}

\noindent ZeroStrain($\overrightarrow{\Delta g}^M$, $U$, $id$):
\begin{itemize}  
\item transition:
	\begin{enumerate}
	\item store($id$,deltagM,$\overrightarrow{\Delta g}_{\text{cor}}^M$) such that
	\begin{equation*}
\overrightarrow{\Delta g}_{\text{cor}}^M = \overrightarrow{\Delta g}^M - \text{lsfm}(\overrightarrow{\Delta g}^M,U)
	\end{equation*}
	\item store($id$,gMuns,$\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}$) such that
	\begin{equation*}
\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}} = \overrightarrow{g}^{M_{\text{exp}}} + \text{lsfm}(\overrightarrow{\Delta g}^M,U)
	\end{equation*}
	\end{enumerate}	 
\item exception:
\end{itemize}

\section{MIS of Conversion Module (\texorpdfstring{\cref{MG:M_MtoCConv}}))} \label{MIS_MtoCConv}

\subsection{Module}
MtoCConv
\subsection{Uses}
\begin{itemize}
\item Data Structure (\cref{MG:M_DataStruct}, \cref{MIS_DataStruct})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
conversion & $p \in \mathbb{R}$ , $(n,m) \in \mathbb{N}^2$, $\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}:\mathbb{I}\rightarrow\mathbb{R}^2$ , $id : \text{id GUI object}$  & $\overrightarrow{g_{uns}}^{C_{exp}}:\mathbb{I}\rightarrow\mathbb{R}^2$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
data : object

\subsubsection{Access Routine Semantics}

\noindent conversion($p,n,m,\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}},id$):
\begin{itemize}
\item transition: store{\_}g($id$,gCuns,$\overrightarrow{g_{j}}_{\text{uns}}^{C_{\text{exp}}}$) such that
	\begin{equation*}
	\forall \vec{r} \in \mathbb{I}, \
	\overrightarrow{g_{j}}_{\text{uns}}^{C_{\text{exp}}}(\vec{r})= \overrightarrow{g_{j}}_{\text{uns}}^{M_{\text{exp}}}(\vec{r}) + p \times \begin{bmatrix}
	n \\
	m
	\end{bmatrix}
	\end{equation*}
\item exception:
\end{itemize}

\section{MIS of 2D Strain Tensor Module (\texorpdfstring{\cref{MG:M_StrainCalc}}))} \label{MIS_StrainCalc}

\subsection{Module}
2D{\_}Strain
\subsection{Uses}
Data Structure (\cref{MG:M_DataStruct}, \cref{MIS_DataStruct})
\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
CalcStrain & $g_{1_{{\text{uns}}}}^{C_{\text{exp}}}:\mathbb{I}\rightarrow\mathbb{R}^2$ , $g_{2_{{\text{uns}}}}^{C_{\text{exp}}}:\mathbb{I}\rightarrow\mathbb{R}^2$ , $\Delta g_{1_{{\text{uns}}}}^{C_{\text{exp}}}:\mathbb{I}\rightarrow\mathbb{R}^2$ , $\Delta g_{2_{{\text{uns}}}}^{C_{\text{exp}}}:\mathbb{I}\rightarrow\mathbb{R}^2$  & $\varepsilon_{\mathit{xx}}:\mathbb{I}\rightarrow\mathbb{R}$ , $\varepsilon_{\mathit{yy}}:\mathbb{I}\rightarrow\mathbb{R}$ , $\varepsilon_{\mathit{xy}}:\mathbb{I}\rightarrow\mathbb{R}$ , $\omega_{\mathit{xy}}:\mathbb{I}\rightarrow\mathbb{R}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
data : object

\subsubsection{Access Routine Semantics}

\noindent CalcStrain($g_{1_{{\text{uns}}}}^{C_{\text{exp}}},g_{2_{{\text{uns}}}}^{C_{\text{exp}}},\Delta g_{1_{{\text{uns}}}}^{C_{\text{exp}}},\Delta g_{2_{{\text{uns}}}}^{C_{\text{exp}}}$):
\begin{itemize}
\item transition:
\begin{enumerate}
\item Form ${{G_{\text{uns}}^{\text{exp}}}}$ and $\Delta G^{\text{exp}}$ matrices such that
\begin{equation*}
\begin{gathered}
G_{\text{uns}}^{\text{exp}} =
	\begin{bmatrix}
	g_{1_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} \\
	g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_y}}^{C_{\text{exp}}} 
	\end{bmatrix}, \ 
\Delta G^{\text{exp}}(\vec{r})=
	\begin{bmatrix}
	\Delta g_{1_{x}}^{C_{\text{exp}}} & \Delta g_{1_{y}}^{C_{\text{exp}}}\\
	\Delta g_{2_{x}}^{C_{\text{exp}}} & \Delta g_{2_{y}}^{C_{\text{exp}}}
	\end{bmatrix}
\end{gathered}
\end{equation*}
\item Calculate $\nabla u^{\text{exp}}$ such that
\begin{equation*}
\nabla u^{\text{exp}} = ({[{G_{\text{uns}}^{\text{exp}}}+\Delta G^{\text{exp}}}]^{T})^{-1}{{G_{\text{uns}}^{\text{exp}}}}^{T}-I_{d}
\end{equation*}
\item Calculate $\varepsilon^{\text{exp}}$ and $\omega^{\text{exp}}$
\begin{equation*}
\begin{gathered}
\varepsilon^{\text{exp}} = \frac{1}{2}(\nabla u^{\text{exp}}+(\nabla u^{\text{exp}})^{T})= \begin{bmatrix}
	\varepsilon_{\mathit{xx}} & \varepsilon_{\mathit{xy}} \\
	\varepsilon_{\mathit{xy}} & \varepsilon_{\mathit{yy}}
	\end{bmatrix} \\
\omega^{\text{exp}} = \frac{1}{2}(\nabla u^{\text{exp}}-(\nabla u^{\text{exp}})^{T})= \begin{bmatrix}
	0 & \omega_{\mathit{xy}} \\
	-\omega_{\mathit{xy}} & 0
	\end{bmatrix}
\end{gathered}
\end{equation*}
\item store(Exx,$\varepsilon_{\mathit{xx}}$), store(Eyy,$\varepsilon_{\mathit{yy}}$), store(Exy,$\varepsilon_{\mathit{xy}}$), store(Rxy,$\omega_{\mathit{xy}}$) 
\end{enumerate}  
\item exception:
\end{itemize}

\section{MIS of Fourier Transform Module (\texorpdfstring{\cref{MG:M_FT}}))} \label{MIS_FT}
\textit{{\#} 2D Fourier transform}
\subsection{Module}
FTCalc
\subsection{Uses}
None
\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
$\mathcal{FT}$ & $f:\mathbb{R}^2\rightarrow\mathbb{R}$ & $f:\mathbb{R}^2\rightarrow\mathbb{C}$ & - \\
i$\mathcal{FT}$ & $f:\mathbb{R}^2\rightarrow\mathbb{C}$ & $f:\mathbb{R}^2\rightarrow\mathbb{R}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None

\subsubsection{Access Routine Semantics}

\noindent\textit{{\#} Calculate the 2D Fourier transform of a function $f$} \medskip

\noindent $\mathcal{FT}$($f(x,y)$):
\begin{itemize} 
\item output: $\widetilde{f}(\nu,\mu)$ such that 
\begin{equation*}
\forall (\nu,\mu) \in \mathbb{R}^2 \wedge \forall (x,y) \in \mathbb{R}^2, \ \widetilde{f}(\nu,\mu)=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}f(x,y)e^{-2i\pi(\nu x+\mu y)}dxdy
\end{equation*}
\item exception:
\end{itemize}

\noindent\textit{{\#} Calculate the 2D inverse Fourier transform of a function $\widetilde{f}$}\medskip

\noindent i$\mathcal{FT}$($\widetilde{f}(\nu,\mu)$):
\begin{itemize} 
\item output: $f(x,y)$ such that 
\begin{equation*}
\forall (x,y) \in \mathbb{R}^2 \wedge \forall (\nu,\mu) \in \mathbb{R}^2 , \ f(x,y)=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\widetilde{f}(\nu,\mu)e^{2i\pi(\nu x+\mu y)}dxdy
\end{equation*}
\item exception:
\end{itemize}

\section{MIS of Gradient Module (\texorpdfstring{\cref{MG:M_Gradient}}))} \label{MIS_Gradient}

\textit{{\#} 2D Gradient} \medskip

\subsection{Module}
GradCalc
\subsection{Uses}
None
\subsection{Syntax}

\subsubsection{Exported Access Programs}
\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
grad & $f:\mathbb{R}^2\rightarrow\mathbb{R}$  & $f:\mathbb{R}^2\rightarrow\mathbb{R}^2$ & -\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None

\subsubsection{Access Routine Semantics}

\noindent\textit{{\#} Calculate the gradient of a 2D function $f$} \medskip

\noindent grad($f$):
\begin{itemize} 
\item output:$ \nabla f(x,y)$ such that
\begin{equation*}
\forall (x,y) \in \mathbb{R}^2, \ \nabla f(x,y) = \begin{bmatrix}
\frac{\partial f}{\partial x}(x,y) \\
\frac{\partial f}{\partial y}(x,y)
\end{bmatrix}
\end{equation*}
\item exception: 
\end{itemize}

\section{MIS of Least Square Fit Method Module (\texorpdfstring{\cref{MG:M_LSFM}}))} \label{MIS_LSFM}

\textit{{\#} 2D linear least square method to fit a function $f$} \medskip

\subsection{Module}
LSFMCalc
\subsection{Uses}
None
\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
lsfm & $f:\mathbb{R}^2\rightarrow\mathbb{R}^2$, $U \in \mathbb{R}^2$ & $f:\mathbb{R}^2\rightarrow\mathbb{R}^2$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None

\subsubsection{Access Routine Semantics}

\noindent\textit{{\#} Calculate the 2D fit of a function $f$ using the linear least square method on a domain $U=([x_0,x_1];[y_0,y_1]) \in \mathbb{R}^2$} \medskip

\noindent lsfm(f,U):
\begin{itemize}
\item output: $fit(x,y)=ax + by$ such that
\begin{equation*}
\begin{gathered}
\forall (x,y) \in U, \ E(a,b)=\int_{x_0}^{x_1}\int_{y_0}^{y_1}[f(x,y)-fit(x,y)]^2dxdy \ \ \text{is minimized} \\
\Rightarrow \frac{\partial E}{\partial a} =0 \wedge \frac{\partial E}{\partial b} =0
\Rightarrow a = \frac{\int_{x_0}^{x_1}\int_{y_0}^{y_1}xf(x,y)dxdy}{\int_{x_0}^{x_1}\int_{y_0}^{y_1}x^2dxdy} \wedge  b= \frac{\int_{x_0}^{x_1}\int_{y_0}^{y_1}yf(x,y)dxdy}{\int_{x_0}^{x_1}\int_{y_0}^{y_1}y^2dxdy}
\end{gathered}
\end{equation*}
\item exception:
\end{itemize}


\section{MIS of Phase Operation Module (\texorpdfstring{\cref{MG:M_Phase}}))} \label{MIS_Phase}

\subsection{Module}
PhaseCalc
\subsection{Uses}
None
\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
unwrap & $f:\mathbb{R}^2\rightarrow]-\pi,\pi]$ & $f:\mathbb{R}^2\rightarrow\mathbb{R}$ & -  \\
wrap & $f:\mathbb{R}^2\rightarrow\mathbb{R}$ & $f:\mathbb{R}^2\rightarrow]-\pi,\pi]$ & - \\
arg & $z \in \mathbb{C}$ & $\phi \in ]-\pi,\pi]$ &  - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None

\subsubsection{Access Routine Semantics}

\noindent wrap($f$):
\begin{itemize} 
\item output: $g$ such that
\begin{equation*}
\forall (x,y) \in \mathbb{R}^2, \exists k \in \mathbb{Z} | g(x,y) =f(x,y)+ 2k\pi \wedge g(x,y) \in ]-\pi,\pi]
\end{equation*} 
\item exception:
\end{itemize}

\noindent unwrap($f$):
\begin{itemize} 
\item output: $g$ such that
\begin{equation*}
\begin{gathered}
\forall (x,y) \in \mathbb{R}^2, \exists k \in \mathbb{Z} | g(x,y) =f(x,y) + 2k\pi \wedge g \ \text{is} \  \text{continous}\\
\Rightarrow \forall (x,y) \in \mathbb{R}^2, \exists k \in \mathbb{Z} | \lim_{(x,y)\to (x_0,y_0)} g(x,y) = g(x_0,y_0) = f(x_0,y_0) + 2k\pi
\end{gathered}
\end{equation*}
\item exception:
\end{itemize}

\noindent arg($z$):
\begin{itemize} 
\item output: $\phi$ such that
\begin{equation*}
\phi=\text{arg}(z) \text{ with } z=e^{i\phi}
\end{equation*}
\item exception:
\end{itemize}


\section{MIS of Data Structure Module (\texorpdfstring{\cref{MG:M_DataStruct}}))} \label{MIS_DataStruct}

\subsection{Module}
DataStruct
\subsection{Uses}
None
\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
store & string $\times$ object & - & - \\
read & string & object & - \\
store{\_}g & id GUI object $\times$ string $\times$ object & - & - \\
read{\_}g & id GUI object $\times$ string & object & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\noindent\textit{{\#} Structure of the object carrying the data information}\medskip

data : object
\begin{itemize}
\item data(ISMHexp)=$I_{\mathit{SMH}_{\text{exp}}}$
\item data(pISMHexp)= $p$
\item data(ICref)=$I_{\mathit{C}_{\text{ref}}}$
\item data(pICref)=$p_{\text{ref}}$
\item data(FTISMHexp)=$\widetilde{I}_{\mathit{SMH}_{\text{exp}}}$
\item data(FTISMHsim)=$\widetilde{I}_{\mathit{SMH}_{\text{sim}}}$
\item for each $j$ data(T$j$) : object 
	\begin{itemize}
	\item data(T$j$)(gMuns)=$\overrightarrow{g_{j}}_{\text{uns}}^{M_{\text{exp}}}$
	\item data(T$j$)(deltagM)=$\Delta \overrightarrow{g_{j}}^{M_{\text{exp}}}$
	\item data(T$j$)(PhasegM)=$P_{\Delta \overrightarrow{g_{j}}^{M_{\text{exp}}}}$
	\item data(T$j$)(shift)=$(n_j,m_j)$
	\item data(T$j$)(gCuns)=$\overrightarrow{g_{j}}_{\text{uns}}^{C_{\text{exp}}}$
	\end{itemize}
\item data(Exx)=$\varepsilon_{\text{xx}}$
\item data(Eyy)=$\varepsilon_{\text{yy}}$
\item data(Exy)=$\varepsilon_{\text{xy}}$
\item data(Rxy)=$\omega_{\text{xy}}$
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent store($a$,$b$):
\begin{itemize}
\item transition: data($a$)=$b$
\end{itemize}

\noindent load($a$):
\begin{itemize}
\item output: data($a$)
\end{itemize}

\noindent store{\_}g($id$,$a$,$b$):
\begin{itemize}
\item transition: data($id$)($a$)=$b$
\end{itemize}

\noindent load{\_}g($id$,$a$):
\begin{itemize}
\item output: data($id$)($a$)
\end{itemize}

\section{MIS of Generic GUI/Plot Module (\texorpdfstring{\cref{MG:M_GUIGene}}))} \label{MIS_GUIGene}

\subsection{Module}
GUIGene
\subsection{Uses}
Hardware-Hiding (\cref{MG:M_Hardware})
\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
plot & GUI objects & - & - \\
fig & string $\times$ GUI objects &  GUI object & - \\
button & $k \in \mathbb{N}$ , {string}$^{k}$ &  GUI object & - \\
entry{\_}field & string &  GUI object & - \\
circle & - &  GUI object & - \\
rectangle & - & GUI object & - \\
read{\_}user{\_}GUI & GUI object & object \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None

\subsubsection{Access Routine Semantics}

\noindent plot():
\begin{itemize}
\item output: Display on the Hardware all the GUI objects 
\end{itemize}

\noindent fig('label', optional GUI objects):
\begin{itemize}
\item output: Create a window GUI object with the optional GUI objects
\end{itemize}

\noindent button($number$,'labels'):
\begin{itemize}
\item output: Create $number$ buttons GUI objects with their respective 'labels'
\end{itemize}

\noindent entry{\_}field($b$):
\begin{itemize}
\item output: Create a entry field GUI object to collect the input $b$ from the user
\end{itemize}

\noindent circle($C$(user{\_}param)):
\begin{itemize}
\item output: Create a circle $C$ GUI object drawn by the user 
\end{itemize}

\noindent rectangle($R$(user{\_}param)):
\begin{itemize}
\item output: Create a rectangle $R$ GUI object drawn by the user 
\end{itemize}

\noindent read{\_}user{\_}GUI($A$):
\begin{itemize}
\item output:  $B$ such that B includes the id of the GUI and the type of the GUI
\end{itemize}
\bigskip

\newpage

\bibliographystyle{ieeetr}
\bibliography{MIS}

\newpage

\section{Appendix} \label{Appendix}

\end{document}