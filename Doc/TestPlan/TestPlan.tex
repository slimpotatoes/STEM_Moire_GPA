\documentclass[12pt, titlepage]{article}

% Author's up-front packages
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{longtable}

%Packages on template
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{xr-hyper}
\usepackage{hyperref}


% ---- Author's choice to remove them ----
%\usepackage[round]{natbib}

% Author's packages

\usepackage{amsmath, mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{indentfirst}
\usepackage{float}
\usepackage{csquotes}
\usepackage{cleveref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\newcommand{\progname}{STEM Moir{\'e} GPA}
\externaldocument[ext:]{../SRS/SRS}

%Set the custom referencing system (author's initiative)
	% Goal Statement
\newtheorem{GS}{GS}
\crefname{GS}{GS}{GSs}
	% Assumption
\newtheorem{A}{A}
\crefname{A}{A}{As}
	% Theoretical Model
\newtheorem{T}{T}
\crefname{T}{T}{Ts}
	% Data Definition
\newtheorem{DD}{DD}
\crefname{DD}{DD}{DDs}
	% Data Constraints
\newtheorem{DC}{DC}
\crefname{DC}{DC}{DCs}
	% Instance Model
\newtheorem{IM}{IM}
\crefname{IM}{IM}{IMs}
	% General Definition
\newtheorem{GD}{GD}
\crefname{GD}{GD}{GDs}
	% Requirement
\newtheorem{R}{R}
\crefname{R}{R}{Rs}
	% Non Functional Requirement
\newtheorem{NR}{NR}
\crefname{NR}{NR}{NRs}
	% Likely change
\newtheorem{LC}{LC}
\crefname{LC}{LC}{LCs}
	% Test
\newtheorem{Test}{Test}
\crefname{Test}{Test}{Tests}

\input{../Comments}


\begin{document}

\title{Test Plan:\\
		STEM Moir{\'e} GPA} 
\author{Alexandre Pofelski \\
		macid: pofelska \\
		github: slimpotatoes}
\date{\today}
	
\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{table}[h]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
23/10/2017 & 1.0 & First Draft\\
\bottomrule
\end{tabularx}
\end{table}

~\newpage

\section{Symbols, Abbreviations and Acronyms}
\label{symbols}

Symbols, Abbreviations and Acronyms used in the Test Plan document are regrouped under the following table, in \cref{ext:table_symbols_SRS} and in \cref{ext:table_acro_SRS} of the SRS document. \par\medskip

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  GUI & Graphical Unit Interface \\
  N/A & Non-Applicable \\
  \bottomrule
  \label{table_acro_Test_Plan}
\end{tabular}


\newpage

\tableofcontents

\listoftables

\newpage

\pagenumbering{arabic}


\section{General Information}

\subsection{Purpose}

The purpose of the document is to provide the plan for testing
\progname{} software with respect to the requirements specified in the
SRS document.  \wss{An explicit web-link to your GitHub repo would be nice.}

\subsection{Scope}

The scope of the test plan is described below:
\begin{itemize}
\item \progname{} will be written in Python.
\item The proposed test plan is focusing on system and unit testing to
  verify the functional and non functional requirements of
  \progname{}. Because of the nature of \cref{ext:IM_1},
  \cref{ext:IM_2} and \cref{ext:IM_3} (see SRS document), a complete
  verification of their respective outputs is not possible. In these
  cases, the system tests are designed as validation tests (including
  algorithm errors) and will not catch a code error \wss{Do you mean
    ``will not distinguish a code error for a modelling error''?}. A physical
  understanding of the test output is recommended to interpret
  properly its quantitative aspect, since an assessment by the test
  team on the quality of the test results is required to validate it
  (reasonable error?). If the error observed is unreasonably high, an
  error in the code tested might be postulated.
\item Regarding the numerous requirements of \progname{} and their
  relative complexity to be fully verified, only a portion of
  \progname{} is proposed to be tested. A specific focus is proposed
  on key aspects that are identified as the highest potential source
  of errors. The testing of the GUI won't be approached in this
  document but should be definitely considered in the future.
\end{itemize}

\wss{The text is better for version control, and for reading in other editors,
  if you use a hard-wrap at 80 characters}

\section{Plan}

Based on the scope of the test plan, only \cref{ext:R_2}, \cref{ext:R_3}, \cref{ext:R_6}, \cref{ext:R_7}, \cref{ext:R_9}, \cref{ext:R_10}, \cref{ext:R_12}, \cref{ext:R_13}, \cref{ext:NR_1}, \cref{ext:NR_2}, \cref{ext:NR_8} and \cref{ext:NR_9} are planned to be verified and/or validated. 

\wss{Nice to see the external references!}
	
\subsection{Software Description}

\progname{} software is converting a STEM Moir{\'e} hologram into deformation maps. Details on the goal and the requirements of \progname{} are provided in the Problem Statement and the SRS documents.

\subsection{Test Team}

The author of the document is the only member of the test team.

\subsection{Automated Testing Approach}

By predefining some user inputs, an automated testing approach can be considered. The unit tests and most of the system tests will be executed and validated automatically. Some system tests (\cref{T_Phase-Extraction-No-Strain}, \cref{T_Phase-Extraction-Known-Strain}, \cref{T_Phase-Extraction-Mask}, \cref{T_constant-delta-g-with-noise}, \cref{T_varying-delta-g}, \cref{black_box_STEM_Moire_GPA}) require at least a manual assessment of the test results and are thus removed from the automated scope.

\subsection{Verification Tools}

With respect to the limited experience of the test team regarding verification and validation, only a unit test framework is going to be used as verification tools. \textbf{Pytest}, a Python unit test framework, will be used to test \progname{} software.

\subsection{Non-Testing Based Verification}

N/A\an{Possible to put Isobel to go through the code but I don't want
  to add it in this document since the code inspection is a favor and
  not part of the plan :).}  \wss{Okay.  That sound fair.}

\section{System Test Description}
	
\subsection{Tests for Functional Requirements}
\renewcommand{\labelitemi}{$\star$}

\subsubsection{Output Verfication (and/or Validation) tests}
	
\paragraph{Test \cref{ext:R_3} in \cref{ext:IM_1}: Correctness of the sampling theory application when undersampling g}

\begin{Test}\normalfont\underline{Test-aliasing-frequency-simple}
\label{aliasing-frequency-simple}
\begin{itemize}
\item Type: Functional, Dynamical, Automated
\item Initial State: N/A
\item Input: $I_{C_{\text{ref}}}=e^{2i\pi gx}$, $p$ such that $\overrightarrow{q}=\frac{1}{p}\vec{u_x}$
\item Expected output : $\widetilde{I}_{\mathit{SHM}_{\text{sim}}}=\delta(\vec{\nu}-\vec{q})$
\item Output: ${\widetilde{I}_{\mathit{SHM}_{\text{sim}}}}^{t}$ to be tested as a Dirac delta function at $\overrightarrow{q}$
\end{itemize}
\end{Test}
		
The position in frequency space of the aliased frequency (transformation of one $\overrightarrow{g_{j}}^{C_{\text{ref}}}$ from $I_{C_{\text{ref}}}$ to one $\overrightarrow{g_{j}}^{M_{\text{ref}}}$ of $I_{\mathit{SMH}_{\text{sim}}}$) is key to identify the vector $\overrightarrow{q_{n_j,m)j}}$. \Cref{aliasing-frequency-simple} is designed to check if the most basic transformation when under sampling is correctly performed. More complex versions of \Cref{aliasing-frequency-simple} can be designed with reference functions having, for example, a continuous description in Fourier space. Nevertheless, the more complex tests will cover way more cases than what $I_{C_{\text{ref}}}$ typically is (a sparse function). Depending on the time availability, a more complete version of \cref{aliasing-frequency-simple} will be designed.
		
\paragraph{Test \cref{ext:R_7} in \cref{ext:IM_2}: Correctness of the GPA method application} 

\begin{Test}\normalfont\underline{Test-Phase-Extraction-No-Strain}
\label{T_Phase-Extraction-No-Strain}
\begin{itemize}
\item Type: Functional, Dynamical, Automated
\item Initial State: N/A
\item Input: $I_{SMH_{exp}}=e^{2i\pi gx}$, Mask $M$ of one pixel at $g\overrightarrow{u_x}$ in $\widetilde{I}_{SMH_{exp}}$
\item Expected output $P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}=0$, $\Delta \overrightarrow{g_{j}}^{M_{exp}}=\overrightarrow{0}$, 
\item Test output:${P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}^{t}$, $\Delta {\overrightarrow{g_{j}}^{M_{exp}}}^{t}$
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r})=|{P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}^{t}(\vec{r})|$
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r})=|{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}^t(\vec{r})|$
	\end{itemize}  
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Phase-Extraction-Known-Strain}
\label{T_Phase-Extraction-Known-Strain}
\begin{itemize}
\item Type: Functional, Dynamical, Manual
\item Initial State: N/A
\item Input: $I_{SMH_{exp}}=e^{2i\pi (g+K(x))x}$, Mask $M$ centred on $g\overrightarrow{u_x}$ in $\widetilde{I}_{SMH_{exp}}$ and with the minimum radius to include $K(x)$. 
\item Expected output $P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}=K(x)x$, $\Delta \overrightarrow{g_{j}}^{M_{exp}}=K(x)\overrightarrow{u_x}$, 
\item Test output:${P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}^{t}$, $\Delta {\overrightarrow{g_{j}}^{M_{exp}}}^{t}$
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r})=|{P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}^{t}(\vec{r})-P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}(\vec{r})|$
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r})=|{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}^t(\vec{r})-{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r})|$
	\end{itemize}  
\end{itemize}
\end{Test}				
 
\begin{Test}\normalfont\underline{Test-Phase-Extraction-Mask}
\label{T_Phase-Extraction-Mask}
\begin{itemize}
\item Type: Functional, Dynamical, Manual
\item Initial State: N/A
\item Input: $I_{SMH_{exp}}=e^{2i\pi (g+H(x))x}$, Mask $M$ centred on $g\overrightarrow{u_x}$ in $\widetilde{I}_{SMH_{exp}}$ with different radius $\epsilon$. 
\item Expected output $P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}=H(x)x$, $\Delta \overrightarrow{g_{j}}^{M_{exp}}=H(x)\overrightarrow{u_x}$, 
\item Test output:${P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}^{t}$, $\Delta {\overrightarrow{g_{j}}^{M_{exp}}}^{t}$
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r},\epsilon)=|{P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}^{t}(\vec{r},\epsilon)-P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}(\vec{r})|$
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r},\epsilon)=|{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}^t(\vec{r},\epsilon)-{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r})|$
	\end{itemize}
\end{itemize}
\end{Test}						

Because the GPA method is itself based on an approximation (see
\cref{ext:IM_2} in SRS document), errors from the algorithm are added
to the errors from the code. Both are probed at the same time in the
tests and cannot be fully
separated. \Cref{T_Phase-Extraction-No-Strain} is probing the accuracy
and the precision in the most basic case possible (no strain) and is a
first indicator of the \cref{ext:IM_2}
performance. \Cref{T_Phase-Extraction-Known-Strain} and
\cref{T_Phase-Extraction-Mask} are closer to a real case scenario and
highlight a more realistic version of \cref{ext:IM_2} performance. To
get quantitative trends, the error will be characterized as a function
of the mask properties (such as the radius) and the deformation
magnitude. This characterization will allow the GPA algorithm of
\progname{} to be compared with other software using the same GPA
algorithm. Another interest of the performance characterization is to
see a quantitative effect of the user inputs on \cref{ext:IM_2} and
provide a ``good practice guidance'' in the user manual.  \wss{I like
  this idea!}

\paragraph{Test \cref{ext:R_10} in \cref{ext:IM_3}: Correctness of the unstrained reference calculation}	

\begin{Test}\normalfont\underline{Test-constant-delta-g}
\label{T_constant-delta-g}
\begin{itemize}
\item Type: Functional, Dynamical, Automated
\item Initial State: 
\item Input: 
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \  \Delta \overrightarrow{g}^{M_{\text{exp}}}(\vec{r})=\overrightarrow{C}$
	\item $U$ array of 1 pixel wherever on $\Delta \overrightarrow{g}^{M_{\text{exp}}}(\vec{r})$
	\item $\overrightarrow{g}^{M_{\text{exp}}}={g_x}^{M_{\text{exp}}}\overrightarrow{u_x}+{g_y}^{M_{\text{exp}}}\overrightarrow{u_y}$
	\end{itemize} 
\item Expected output: $\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}=\overrightarrow{g}^{M_{\text{exp}}}-\overrightarrow{C}$, $\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}=\overrightarrow{0}$
\item Output:${\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}^{t}$ , ${\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}^{t}$
	\begin{itemize}
	\item $E_{\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}=||{\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}^{t}-\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}||$
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}=||{\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}^{t}||$
	\end{itemize}
\end{itemize}
\end{Test}

\Cref{T_constant-delta-g} is not realistic but test the code
directly. Increasing the size of U, \wss{write as $U$}should have absolutely no effect on the output. 

\begin{Test}\normalfont\underline{Test-constant-delta-g-with-noise}
\label{T_constant-delta-g-with-noise}
\begin{itemize}
\item Type: Functional, Dynamical, Manual (can be automated)
\item Initial State: 
\item Input: 
	\begin{itemize}
	\item $\overrightarrow{N}$, 2D random noise
	\item $\forall \vec{r} \in \mathbb{I}, \ \Delta \overrightarrow{g}^{M_{\text{exp}}}(\vec{r})=\overrightarrow{C} + \overrightarrow{N}$
	\item $U$ array of $n \times m$ pixels wherever on $\Delta \overrightarrow{g}^{M_{\text{exp}}}(\vec{r})$ 
	\item $\overrightarrow{g}^{M_{\text{exp}}}={g_x}^{M_{\text{exp}}}\overrightarrow{u_x}+{g_y}^{M_{\text{exp}}}\overrightarrow{u_y}$
	\end{itemize}
\item Expected output: $\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}=\overrightarrow{g}^{M_{\text{exp}}}-\overrightarrow{C}$,  $\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}=\overrightarrow{0}$
\item Output:${\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}^{t}, {\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}^{t}$
	\begin{itemize}
	\item $E_{\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}=||{\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}^{t}-\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}||$
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}=||{\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}^{t}||$
	\end{itemize}
\end{itemize}
\end{Test}

\Cref{T_constant-delta-g-with-noise} is more representative of a real
case than \cref{T_constant-delta-g} and will be use to characterize
the evolution of the error with respect to the level of noise and the
size of U. If the error is unreasonably high, an error in the code can
be postulated. The evaluation of
$\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}$ is critical on the
quantitative estimation of strain and rotation.  \wss{I like this
  test, but (as for several other tests), there are still decisions
  that could be made that you have postponed.  Specifically, what are
  the values of $m$ and $n$?  If the data is difficult to specify,
  maybe you could point to a sample file in your repo that you are
  going to use?}

\begin{Test}\normalfont\underline{Test-varying-delta-g}
\label{T_varying-delta-g}
\begin{itemize}
\item Type: Functional, Dynamical, Manual
\item Initial State: 
\item Input: 
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \ \overrightarrow{g}^{M_{\text{exp}}}(\vec{r})=\overrightarrow{C}(\vec{r})$
	\item $U$ array of $n \times m$ pixels wherever on $\Delta \overrightarrow{g}^{M_{\text{exp}}}(\vec{r})$
	\item $\overrightarrow{g}^{M_{\text{exp}}}={g_x}^{M_{\text{exp}}}\overrightarrow{u_x}+{g_y}^{M_{\text{exp}}}\overrightarrow{u_y}$
\end{itemize}
\item Expected output: $\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}=\overrightarrow{g}^{M_{\text{exp}}}-F(\overrightarrow{C}(\vec{r}))$,   $\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}=\overrightarrow{C}(\vec{r})-F(\overrightarrow{C}(\vec{r}))$ where $F(\overrightarrow{C}(\vec{r}))$ is the best possible linear fit of $\overrightarrow{C}(\vec{r})$ in $U$.
\item Output:${\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}^{t}, {\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}^{t}$
	\begin{itemize}
	\item $E_{\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}=||{\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}^{t}-\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}||$
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}=||{\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}^{t}-\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}||$
	\end{itemize}
\end{itemize}
\end{Test}

\Cref{T_varying-delta-g} might be impossible to properly interpret but the idea is to see the effect an improper choice of an unstrained reference. If a non uniform deformation field is present in the reference, \progname{} is trying to find the best linear fit. A solution is calculated whatever the precision of the fit. However, if the quality of the fit is poor, it could be possible that \progname{} informs/warns the user of a potential problem in the reference chosen.


\subsection{Tests for Nonfunctional Requirements}

\subsubsection{Evolution of precision with noise in \progname{}}
		
\paragraph{Test \cref{ext:NR_8} and \cref{ext:NR_9}}						

\begin{Test}\normalfont\underline{Test-Black-Box-STEM-Moir{\'e}-GPA}
\label{black_box_STEM_Moire_GPA}
\begin{itemize}
\item Type: Functional, Dynamical, Black box, , Manual (can be automated)
\item Initial State: All user inputs are predefined ($p,M_1,M_2,U,\overrightarrow{q_{n_1,m_1}},\overrightarrow{q_{n_2,m_2}}$) except the STEM Moir{\'e} hologram
\item Input: STEM Moir{\'e} holograms with different level of noise (from no noise to high level of noise): 
	\begin{itemize}
	\item	$I_{\mathit{SMH}_\text{exp}} = I(\vec{r}) + N(\vec{r})$ with $I$ a perfect SMH (with a defined strain field $\varepsilon(\vec{r})$ and rotation field $\omega(\vec{r})$) and $N$ a random noise
	\end{itemize}
\item Expected output $\forall \vec{r} \in \mathbb{I}, \ \varepsilon(\vec{r})^{t}=\varepsilon(\vec{r}) \wedge \omega\vec({r})^{t}=\omega(\vec{r})$
\item Output:
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \ E^{\text{\progname{}}}_{\varepsilon}=|\varepsilon(\vec{r})^{t}-\varepsilon(\vec{r})|$
	\item $\forall \vec{r} \in \mathbb{I}, \ E^{\text{\progname{}}}_{\omega}=|\omega(\vec{r})^{t}-\omega(\vec{r})|$
	\end{itemize}
\end{itemize}
\end{Test}

\Cref{black_box_STEM_Moire_GPA} looks more like a validation test than a verification test. Nevertheless, if the error in \cref{black_box_STEM_Moire_GPA} is unreasonably high, it is possible to consider the presence of a mistake in the code somewhere. On the validation side, \cref{black_box_STEM_Moire_GPA} is highlighting the accuracy (without noise), and the precision (with noise) of \progname{} seen by the end-user (code, user and algorithm errors included). The performance is then characterized as the error output function of the noise (or of the quality factor of $I_{\mathit{SMH}_{\text{exp}}}$ like the signal on noise ratio $\mathit{SNR}=\frac{I_{\mathit{SMH}_\text{exp}}}{N}$). The performance characterization can be used to see from which quality factor the accuracy and sensitivity of \progname{} is too poor to consider the strain and rotation results reliable and warn the user in this case. The performance graph can also be as a base of comparison with another software (if it exists) doing the same data treatment.

\wss{I like how you have used the words verification and validation
  consistently and correctly.}

\subsubsection{Evolution of the time calculations with data size}
		
\paragraph{Test \cref{ext:NR_2}}

\begin{Test}\normalfont\underline{Test-stress-STEM-Moir{\'e}-GPA}
\label{stress_test_STEM_Moire_GPA}
\begin{itemize}
\item Type: Functional, Dynimical, \wss{spell check!} Black box, Manual
\item Initial State: All user inputs are predefined ($p,M_1,M_2,U,\overrightarrow{q_{n_1,m_1}},\overrightarrow{q_{n_2,m_2}}$) except the STEM Moir{\'e} hologram
\item Input: STEM Moir{\'e} holograms with different 2D array size.
\item Expected output $\forall \vec{r} \in \mathbb{I}, \
  \varepsilon(\vec{r})^{t}=\varepsilon(\vec{r}) \wedge
  \omega\vec({r})^{t}=\omega(\vec{r})$ in a reasonable time frame
  \wss{This could be less ambiguous.  Specifying a specific time would
    not be much more meaningful, but maybe you could do a usability
    test?  More realistically, you could just record the times for the
    tests and plot this data for others to consider.  Rather than
    specify the performance, you are simply describing the performance
    as observed experimentally.}
\item Output: Time to perform all the calculations
\end{itemize}
\end{Test}

\subsubsection{Evolution of the accuracy of \progname{} with environment (reproducibility)}

\paragraph{Test \cref{ext:NR_1}}						

\begin{Test}\normalfont\underline{Test-Black-Box-STEM-Moir{\'e}-GPA-Linux}
\label{black_box_STEM_Moire_GPA-predif-Linux}
\begin{itemize}
\item Type: Functional, Dynamical, Black box, Manual
\item Initial State: x64 Linux environment with all user inputs are predefined ($p,M_1,M_2,U,\overrightarrow{q_{n_1,m_1}},\overrightarrow{q_{n_2,m_2}}$) except $I_{\mathit{SMH}_\text{exp}}$ 
\item Input: A perfect generated STEM Moir{\'e} hologram representing all the strain state in each quadrant $\mathbb{I}_{i}$ of the array $\mathbb{I}$ (unstrained in $\mathbb{I}_{1}$, 1{\%} uniaxial strain along $\vec{u_x}$ and $\vec{u_y}$ in $\mathbb{I}_{2}$, 1{\%} shear strain in $\mathbb{I}_{3}$, and  20 mrad rotation $\mathbb{I}_{4}$)
\item Expected output: In each quadrant
\begin{itemize}
\item $\forall \vec{r} \in \mathbb{I}_{1}, \ \varepsilon(\vec{r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix} \ \wedge \ \omega\vec({r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix}$
\item $\forall \vec{r} \in \mathbb{I}_{2}, \ \varepsilon(\vec{r})=\begin{bmatrix}
0.01 & 0 \\
0 & 0.01
\end{bmatrix} \ \wedge \ \omega\vec({r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix}$
\item $\forall \vec{r} \in \mathbb{I}_{3}, \ \varepsilon(\vec{r})=\begin{bmatrix}
0 & 0.01 \\
0.01 & 0
\end{bmatrix} \ \wedge \ \omega\vec({r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix}$
\item $\forall \vec{r} \in \mathbb{I}_{4}, \ \varepsilon(\vec{r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix} \ \wedge \ \omega\vec({r})=\begin{bmatrix}
0 & 0.2 \\
-0.2 & 0
\end{bmatrix}$
\end{itemize}
\item Output: $\varepsilon(\vec{r})^{t}, \omega(\vec{r})^{t}$
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \ E^{\text{\progname{}}}_{\varepsilon\text{ Linux}}=|\varepsilon(\vec{r})^{t}-\varepsilon(\vec{r})|$
	\item $\forall \vec{r} \in \mathbb{I}, \ E^{\text{\progname{}}}_{\omega\text{ Linux}}=|\omega(\vec{r})^{t}-\omega(\vec{r})|$
	\end{itemize}
\end{itemize}
\end{Test}

\wss{Your outputs are unlikely to be an exact match.  There will be
  some epsilon error.  Maybe you could add a blanket statement at the
  start that points this out.  Part of your output could be a summary
  of the observed errors (hopefully as relative errors, not absolute
  errors) for each test output in comparison to the ideal output.}

\begin{Test}\normalfont\underline{Test-Black-Box-STEM-Moir{\'e}-GPA-Mac}
\label{black_box_STEM_Moire_GPA-predif-Mac}
\begin{itemize}
\item Type: Functional, Dynamical, Black box, Manual
\item Initial State: x64 Mac OS X environment with all user inputs are predefined ($p,M_1,M_2,U,\overrightarrow{q_{n_1,m_1}},\overrightarrow{q_{n_2,m_2}}$) except $I_{\mathit{SMH}_\text{exp}}$ 
\item Input: A perfect generated STEM Moir{\'e} hologram representing all the strain state in each quadrant $\mathbb{I}_{i}$ of the array $\mathbb{I}$ (unstrained in $\mathbb{I}_{1}$, 1{\%} uniaxial strain along $\vec{u_x}$ and $\vec{u_y}$ in $\mathbb{I}_{2}$, 1{\%} shear strain in $\mathbb{I}_{3}$, and  20 mrad rotation $\mathbb{I}_{4}$)
\item Expected output: In each quadrant
\begin{itemize}
\item $\forall \vec{r} \in \mathbb{I}_{1}, \ \varepsilon(\vec{r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix} \ \wedge \ \omega\vec({r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix}$
\item $\forall \vec{r} \in \mathbb{I}_{2}, \ \varepsilon(\vec{r})=\begin{bmatrix}
0.01 & 0 \\
0 & 0.01
\end{bmatrix} \ \wedge \ \omega\vec({r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix}$
\item $\forall \vec{r} \in \mathbb{I}_{3}, \ \varepsilon(\vec{r})=\begin{bmatrix}
0 & 0.01 \\
0.01 & 0
\end{bmatrix} \ \wedge \ \omega\vec({r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix}$
\item $\forall \vec{r} \in \mathbb{I}_{4}, \ \varepsilon(\vec{r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix} \ \wedge \ \omega\vec({r})=\begin{bmatrix}
0 & 0.2 \\
-0.2 & 0
\end{bmatrix}$
\end{itemize}
\item Output: $\varepsilon(\vec{r})^{t}, \omega(\vec{r})^{t}$
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \ E^{\text{\progname{}}}_{\varepsilon\text{ Linux}}=|\varepsilon(\vec{r})^{t}-\varepsilon(\vec{r})|$
	\item $\forall \vec{r} \in \mathbb{I}, \ E^{\text{\progname{}}}_{\omega\text{ Linux}}=|\omega(\vec{r})^{t}-\omega(\vec{r})|$
	\end{itemize}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Black-Box-STEM-Moir{\'e}-GPA-Windows}
\label{black_box_STEM_Moire_GPA-predif-Windows}
\begin{itemize}
\item Type: Functional, Dynamical, Black box, Manual
\item Initial State: x64 Windows environment with all user inputs are predefined ($p,M_1,M_2,U,\overrightarrow{q_{n_1,m_1}},\overrightarrow{q_{n_2,m_2}}$) except $I_{\mathit{SMH}_\text{exp}}$ 
\item Input: A perfect generated STEM Moir{\'e} hologram representing all the strain state in each quadrant $\mathbb{I}_{i}$ of the array $\mathbb{I}$ (unstrained in $\mathbb{I}_{1}$, 1{\%} uniaxial strain along $\vec{u_x}$ and $\vec{u_y}$ in $\mathbb{I}_{2}$, 1{\%} shear strain in $\mathbb{I}_{3}$, and  20 mrad rotation $\mathbb{I}_{4}$)
\item Expected output: In each quadrant
\begin{itemize}
\item $\forall \vec{r} \in \mathbb{I}_{1}, \ \varepsilon(\vec{r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix} \ \wedge \ \omega\vec({r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix}$
\item $\forall \vec{r} \in \mathbb{I}_{2}, \ \varepsilon(\vec{r})=\begin{bmatrix}
0.01 & 0 \\
0 & 0.01
\end{bmatrix} \ \wedge \ \omega\vec({r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix}$
\item $\forall \vec{r} \in \mathbb{I}_{3}, \ \varepsilon(\vec{r})=\begin{bmatrix}
0 & 0.01 \\
0.01 & 0
\end{bmatrix} \ \wedge \ \omega\vec({r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix}$
\item $\forall \vec{r} \in \mathbb{I}_{4}, \ \varepsilon(\vec{r})=\begin{bmatrix}
0 & 0 \\
0 & 0
\end{bmatrix} \ \wedge \ \omega\vec({r})=\begin{bmatrix}
0 & 0.2 \\
-0.2 & 0
\end{bmatrix}$
\end{itemize}
\item Output: $\varepsilon(\vec{r})^{t}, \omega(\vec{r})^{t}$
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \ E^{\text{\progname{}}}_{\varepsilon\text{ Linux}}=|\varepsilon(\vec{r})^{t}-\varepsilon(\vec{r})|$
	\item $\forall \vec{r} \in \mathbb{I}, \ E^{\text{\progname{}}}_{\omega\text{ Linux}}=|\omega(\vec{r})^{t}-\omega(\vec{r})|$
	\end{itemize}
\end{itemize}
\end{Test}

\wss{Copying the same test 3 times in a row, with as far as I can tell
  the only difference being the OS is a maintenance headache.  If you
  realize you have to change the test, you have to change it three
  times.  A better version is to give the full test case once, and
  then the subsequence tests can say it is the same, with the one
  variability of OS changed.}

\an{Technically x86 architecture should be also tested.}

\section{Unit Testing Plan}
		
\subsection{Input Verification test}

\paragraph{Test \cref{ext:R_2} in \cref{ext:IM_1}: Existence and Format of $I_{\mathit{SMH}_{\text{exp}}}$, $I_{C_{\text{ref}}}$ and $p$}

\begin{Test}\normalfont\underline{Test-Existence-SMH}
\label{Test-Existence-SMH}
\begin{itemize}
\item Type: Dynamical, Automated
\item Initial State: Waiting for $I_{\mathit{SMH}_{\text{exp}}}$ user input
\item Input: $I_{\mathit{SMH}_{\text{exp}}}$ = $\emptyset$
\item Output: Error message $Err_{I_{\mathit{SMH}_{\text{exp}}}}$ should match: \enquote{No STEM Moir{\'e} hologram, please load a proper image}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Format-SMH}
\label{Test-Format-SMH}
\begin{itemize}
\item Type: Dynamical, Automated
\item Initial State: Waiting for $I_{\mathit{SMH}_{\text{exp}}}$ user input
\item Input: Various $I_{\mathit{SMH}_{\text{exp}}}$ improper format
\item Output: Error message $Err_{I_{\mathit{SMH}_{\text{exp}}}}$ should match: \enquote{Invalid STEM Moir{\'e} hologram format (expecting a 2D array)}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-read-dm3-format}
\label{Test-read-dm3-format}
\begin{itemize}
\item Type: Dynamical, Automated
\item Initial State: Waiting for $I_{\mathit{SMH}_{\text{exp}}}$ or $I_{C_{\text{ref}}}$ user input
\item Input: Pre defined random 2D array in dm3 format with specific tags (calibration, microscope, high tension, ...)
\item Output: Read the tag from the dm3 file and and test each tag collected with the pre defined tags
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Existence-pixel}
\label{Test-Existence-pixel}
\begin{itemize}
\item Type: Dynamical, Automated
\item Initial State: After importing $I_{\mathit{SMH}_{\text{exp}}}$ and format validated
\item Input: $p$=$\emptyset$
\item Output: Error message $Err_{p}$ should match: \enquote{No pixel size found}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Format-pixel}
\label{Test-Format-pixel}
\begin{itemize}
\item Type: Dynamical, Automated
\item Initial State: After importing $I_{\mathit{SMH}_{\text{exp}}}$ and format validated
\item Input: Improper format of $p$
\item Output: Error message $Err_{p}$ should match: \enquote{Invalid pixel size}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Format-Reference}
\label{Test-Format-Reference}
\begin{itemize}
\item Type: Dynamical, Automated
\item Initial State: Waiting for $I_{C_{\text{ref}}}$ user input
\item Input: Various $I_{C_{\text{ref}}}$ improper format
\item Output: Error message $Err_{I_{C_{\text{ref}}}}$ should match: \enquote{Invalid Reference image format (expecting a 2D array)}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Existence-Reference}
\label{Test-Existence-Reference}
\begin{itemize}
\item Type: Dynamical, Automated
\item Initial State: Waiting for $I_{C_{\text{ref}}}$ user input
\item Input: $I_{C_{\text{ref}}}$ = $\emptyset$
\item Output: Error message $Err_{I_{C_{\text{ref}}}}$ should match: \enquote{No Reference image, please load a proper image}
\end{itemize}
\end{Test}


\paragraph{Test \cref{ext:R_6} in \cref{ext:IM_2}: Test of the mask user input}

\begin{Test}\normalfont\underline{Test-Existence-Mask}
\label{Test-Existence-Mask}
\begin{itemize}
\item Type: Dynamical, Automated
\item Initial State: Waiting for $M$ user input on $\widetilde{I}_{\mathit{SMH}_{\text{exp}}}$
\item Input: $M$=$\emptyset$
\item Output:  Error message $Err_{M}$ should match: \enquote{No Mask found}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Format-Mask}
\label{Test-Format-Mask}
\begin{itemize}
\item Type: Dynamical, Automated
\item Initial State: Waiting for $M$ user input on $\widetilde{I}_{\mathit{SMH}_{\text{exp}}}$
\item Input: $M$ improper format (such as 1D array, 2D array out of bounds if  
\item Output:  Error message $Err_{M}$ should match: \enquote{Improper mask format}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Position-Radius-Mask}
\label{Test-Position-Radius-Mask}
\begin{itemize}
\item Type: Dynamical, Automated
\item Initial State: Waiting for $M$ user input on $\widetilde{I}_{\mathit{SMH}_{\text{exp}}}$
\item Input: Mask center =$(0,0)$, Mask radius=3
\item Output: Center of the circle mask positioned in the middle of the 2D array $\widetilde{I}_{\mathit{SMH}_{\text{exp}}}$ and with a radius of 3 pixels
\end{itemize}
\end{Test}

\paragraph{Test \cref{ext:R_9} in \cref{ext:IM_3}: Test of the unstrained region user input}

\begin{Test}\normalfont\underline{Test-Existence-U}
\label{Test-Existence-U}
\begin{itemize}
\item Type: Dynamical, Automated
\item Initial State: Waiting for $U$ user input on $P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}$
\item Input: $U$=$\emptyset$
\item Output:  Error message $Err_{U}$ should match: \enquote{No reference in phase image found}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Format-U}
\label{Test-Format-U}
\begin{itemize}
\item Type: Dynamical, Automated
\item Initial State: Waiting for $U$ user input on $P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}$
\item Input: $U$ improper format
\item Output:  Error message $Err_{U}$ should match: \enquote{Improper reference in phase image format}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Position-U}
\label{Test-Position-U}
\begin{itemize}
\item Type: Dynamical, Automated
\item Initial State: Waiting for $U$ user input on $P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}$
\item Input: 
	\begin{itemize}
	\item Position left top corner=$(10,10)$, 
	\item Position right bottom corner=$(30,40)$.
	\end{itemize}
\item Output: Rectangle center position $(20,25)$, short length $l=20$ pixels and long length $L=30$ pixels
\end{itemize}
\end{Test}

\an{GUI should be tested again here}

\subsection{Output Verification test}

\paragraph{Test \cref{ext:R_12} in \cref{ext:IM_4}: Affine vectorial transformation}

\begin{Test}\normalfont\underline{Test-Basic-affine-transformation}
\label{Test-Basic-affine-transformation}
\begin{itemize}
\item Type: Functional, Dynamical, Automated
\item Initial State: N/A
\item Input: $\overrightarrow{q_{n,m}}=\begin{bmatrix}
1 \\
-2
\end{bmatrix}$, $\overrightarrow{g_{j}}_{\text{uns}}^{M_{\text{exp}}}=\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}=\begin{bmatrix}
1 \\
1
\end{bmatrix}$, $p=3$
\item Output:  $\overrightarrow{g_{j}}_{\text{uns}}^{C_{\text{exp}}}=\begin{bmatrix}
4\\
-5
\end{bmatrix}$, $\Delta\overrightarrow{g_{j}}^{C_{\text{exp}}}=\begin{bmatrix}
1\\
1
\end{bmatrix}$
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Error-pixel-affine-transformation}
\label{Test-Error-pixel-affine-transformation}
\begin{itemize}
\item Type: Functional, Dynamical, Automated
\item Initial State: Whatever $\overrightarrow{q_{n,m}}, \overrightarrow{g_{j}}_{\text{uns}}^{M_{\text{exp}}}, \Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}$
\item Input:$p=0$ or $p=-10$
\item Output: Error message $Err_{p_{\text{affine}}}$ should match: \enquote{Invalid pixel size}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Error-q-affine-transformation}
\label{Test-Error-q-affine-transformation}
\begin{itemize}
\item Type: Functional, Dynamical, Automated
\item Initial State: Whatever $\overrightarrow{q_{n,m}}, \overrightarrow{g_{j}}_{\text{uns}}^{M_{\text{exp}}}, \Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}},$ and $p>0$
\item Input:$\overrightarrow{q_{n,m}}=\begin{bmatrix}
1.3 \\
-1
\end{bmatrix}$ or $\overrightarrow{q_{n,m}}=\begin{bmatrix}
1 \\
-\sqrt{2}
\end{bmatrix}$
\item Output: Error message $Err_{\vec{q}_{\text{affine}}}$ should match: \enquote{Invalid sampling vector $\overrightarrow{q_{n,m}}$}
\end{itemize}
\end{Test}

\paragraph{Test\cref{ext:R_13} in \cref{ext:IM_5}: Strain and rotation calculation}						

\begin{Test}\normalfont\underline{Test-No-2D-strain}
\label{T_No-2D-strain}
\begin{itemize}
\item Type: Functional, Dynamical, Automated
\item Initial State: N/A
\item Input:
\begin{itemize}
	\item $G_{\text{uns}}^{\text{exp}} =
	\begin{bmatrix}
	g_{1_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} \\
	g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_y}}^{C_{\text{exp}}} 
	\end{bmatrix} =\begin{bmatrix}
	1 & 2 \\
	3 & 4 
	\end{bmatrix} $
	\item $\Delta G^{\text{exp}}(\vec{r})=
	\begin{bmatrix}
	\Delta g_{1_{x}}^{C_{\text{exp}}}(\vec{r}) & \Delta g_{1_{y}}^{C_{\text{exp}}}(\vec{r}) \\
	\Delta g_{2_{x}}^{C_{\text{exp}}}(\vec{r}) & \Delta g_{2_{y}}^{C_{\text{exp}}}(\vec{r})
	\end{bmatrix} = \begin{bmatrix}
	0 & 0 \\
	0 & 0 
	\end{bmatrix} $
	\end{itemize} 
\item Expected output:
	\begin{itemize}
	\item  $\forall \vec{r} \in \mathbb{I}, \ \varepsilon^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	\varepsilon_{\mathit{xx}^{\text{exp}}}(\vec{r}) & \varepsilon_{\mathit{xy}^{\text{exp}}}(\vec{r}) \\
	\varepsilon_{\mathit{xy}^{\text{exp}}}(\vec{r}) & \varepsilon_{\mathit{yy^{\text{exp}}}}(\vec{r})
	\end{bmatrix} = \begin{bmatrix}
	0 & 0 \\
	0 & 0 
	\end{bmatrix} $
	\item $\forall \vec{r} \in \mathbb{I}, \  \omega^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & \omega_{\mathit{xy}^{\text{exp}}}(\vec{r}) \\
	-\omega_{\mathit{xy}^{\text{exp}}}(\vec{r}) & 0 
	\end{bmatrix} = \begin{bmatrix}
	0 & 0 \\
	0 & 0 
	\end{bmatrix} $
	\end{itemize}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-known-constant-2D-strain}
\label{T_known-constant-2D-strain}
\begin{itemize}
\item Type: Functional, Dynamical, Automated
\item Initial State: N/A
\item Input:
\begin{itemize}
	\item $G_{\text{uns}}^{\text{exp}} =
	\begin{bmatrix}
	g_{1_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} \\
	g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_y}}^{C_{\text{exp}}} 
	\end{bmatrix} =\begin{bmatrix}
	1 & 0 \\
	0 & 1 
	\end{bmatrix}$
	\item Various $\Delta G^{\text{exp}}(\vec{r}) =
	\begin{bmatrix}
	\Delta g_{1_{x}}^{C_{\text{exp}}}(\vec{r}) & \Delta g_{1_{y}}^{C_{\text{exp}}}(\vec{r}) \\
	\Delta g_{2_{x}}^{C_{\text{exp}}}(\vec{r}) & \Delta g_{2_{y}}^{C_{\text{exp}}}(\vec{r})
	\end{bmatrix}$
		\begin{itemize}
		\item Uniaxial strain along $\vec{u_x}$, $\Delta G^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0.1 & 0 \\
	0 & 0 
	\end{bmatrix} $
		\item Uniaxial strain along $\vec{u_y}$, $\Delta G^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0 \\
	0 & 0.1 
	\end{bmatrix} $
		\item Pure shear strain, $\Delta G^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0.1 \\
	0.1 & 0 
	\end{bmatrix} $
		\item Pure rotation, $\Delta G^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0.1 \\
	-0.1 & 0 
	\end{bmatrix} $
		\end{itemize}	
	
\end{itemize} 
\item Expected output:
	\begin{itemize}
	\item Uniaxial strain along $\vec{u_x}$,\\
	$\begin{cases} 
	\forall \vec{r} \in \mathbb{I}, \ \varepsilon^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	-\frac{1}{11} & 0 \\
	0 & 0
	\end{bmatrix}  \\
	\forall \vec{r} \in \mathbb{I}, \  \omega^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0 \\
	0 & 0 
	\end{bmatrix} 
	\end{cases}$
	\item Uniaxial strain along $\vec{u_y}$,\\
	$\begin{cases} 
	\forall \vec{r} \in \mathbb{I}, \ \varepsilon^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0 \\
	0 & -\frac{1}{11}
	\end{bmatrix}  \\
	\forall \vec{r} \in \mathbb{I}, \  \omega^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0 \\
	0 & 0 
	\end{bmatrix} 
	\end{cases}$
	\item Pure shear strain,\\
	$\begin{cases} 
	\forall \vec{r} \in \mathbb{I}, \ \varepsilon^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & -\frac{1}{11} \\
	-\frac{1}{11} & 0
	\end{bmatrix}  \\
	\forall \vec{r} \in \mathbb{I}, \  \omega^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0 \\
	0 & 0 
	\end{bmatrix} 
	\end{cases}$
	\item Pure rotation,\\
	$\begin{cases} 
	\forall \vec{r} \in \mathbb{I}, \ \varepsilon^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0 \\
	0 & 0
	\end{bmatrix}  \\
	\forall \vec{r} \in \mathbb{I}, \  \omega^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & \frac{1}{11} \\
	-\frac{1}{11} & 0 
	\end{bmatrix} 
	\end{cases}$
	\end{itemize}

\item Output:  ${\varepsilon^{\text{exp}}(\vec{r})}^{t}-\varepsilon^{\text{exp}}(\vec{r}), {\omega^{\text{exp}}(\vec{r})}^{t}- \omega^{\text{exp}}(\vec{r})$  and test them to be 0:
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Improper-$\Delta G^{\text{exp}}$}
\label{T_Bad-G_ref}
\begin{itemize}
\item Type: Functional, Dynamical, Automated
\item Initial State: Whatever $\Delta G^{\text{exp}}(\vec{r})$
\item Input:
\begin{itemize}
	\item $G_{\text{uns}}^{\text{exp}} =
	\begin{bmatrix}
	g_{1_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} \\
	g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_y}}^{C_{\text{exp}}} 
	\end{bmatrix} =\begin{bmatrix}
	1 & 1 \\
	1 & 1 
	\end{bmatrix} $
	\end{itemize} 
\item Output:
Error message $Err_{G_{\text{uns}}^{\text{exp}}}$ should match:
\enquote{Matrix $G_{\text{uns}}^{\text{exp}}$ non invertible, the
  crystalline wave vectors are linked (collinear). Please chose
  \wss{choose} another combination of crystalline wave vectors.}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Improper-$G_{\text{uns}}^{\text{exp}}$}
\label{T_Bad-Delta-G}
\begin{itemize}
\item Type: Functional, Dynamical, Automated
\item Initial State: N/A
\item Input:
\begin{itemize}
	\item $\Delta G^{\text{exp}}+G_{\text{uns}}^{\text{exp}} =
	\begin{bmatrix}
	1 & 1 \\
	1 & 1 
	\end{bmatrix} $
	\end{itemize} 
\item Output:
Error message $Err_{\Delta G^{\text{exp}}}$ should match: \enquote{Matrix $G^{\text{exp}}$ non invertible. If  $G_{\text{uns}}^{\text{exp}}$ is invertible, something is probably wrong with $\Delta G^{\text{exp}}$.}
\end{itemize}
\end{Test}

\section{Traceability: Tests Cases vs Requirements}		

\noindent 
\begin{longtable}{l p{10cm}} 
\toprule
\textbf{Requirement} & \textbf{Test}\\
\midrule
\endhead
\cref{ext:R_1} & Not covered in the Test Plan (GUI)\\
\cref{ext:R_2} & \cref{Test-Existence-SMH}, \cref{Test-Format-SMH}, \cref{Test-read-dm3-format}, \cref{Test-Existence-pixel}, \cref{Test-Format-pixel}, \cref{Test-Format-Reference}, \cref{Test-Existence-Reference} \\
\cref{ext:R_3} & \cref{aliasing-frequency-simple}\\
\cref{ext:R_4} & Not covered in the Test Plan (GUI)\\
\cref{ext:R_5} & Not covered in the Test Plan (GUI)\\
\cref{ext:R_6} & \cref{Test-Existence-Mask}, \cref{Test-Format-Mask}, \cref{Test-Position-Radius-Mask}\\
\cref{ext:R_7} & \cref{T_Phase-Extraction-No-Strain}, \cref{T_Phase-Extraction-Known-Strain}, \cref{T_Phase-Extraction-Mask} \\
\cref{ext:R_8} & Not covered in the Test Plan (GUI)\\
\cref{ext:R_9} & \cref{Test-Existence-U}, \cref{Test-Format-U}, \cref{Test-Position-U} \\
\cref{ext:R_10} & \cref{T_constant-delta-g}, \cref{T_constant-delta-g-with-noise}, \cref{T_varying-delta-g}\\
\cref{ext:R_11} & Not covered in the Test Plan (GUI)\\
\cref{ext:R_12} & \cref{Test-Basic-affine-transformation}, \cref{Test-Error-q-affine-transformation}, \cref{Test-Error-pixel-affine-transformation} \\
\cref{ext:R_13} & \cref{T_No-2D-strain}, \cref{T_known-constant-2D-strain}, \cref{T_Bad-G_ref}, \cref{T_Bad-Delta-G}\\
\cref{ext:R_14} & Not covered in the Test Plan (GUI)\\
\cref{ext:NR_1} & \cref{black_box_STEM_Moire_GPA-predif-Linux}, \cref{black_box_STEM_Moire_GPA-predif-Mac}, \cref{black_box_STEM_Moire_GPA-predif-Windows}\\
\cref{ext:NR_2} & \cref{stress_test_STEM_Moire_GPA}\\
\cref{ext:NR_3} & Not covered in the Test Plan (GUI)\\
\cref{ext:NR_4} & Not covered in the Test Plan (GUI)\\
\cref{ext:NR_5} & Not covered in the Test Plan (Not a priority)\\
\cref{ext:NR_6} & Not covered in the Test Plan (Not a priority)\\
\cref{ext:NR_7} & Not covered in the Test Plan (Not a priority)\\
\cref{ext:NR_8} & \cref{black_box_STEM_Moire_GPA}\\
\cref{ext:NR_9} & \cref{black_box_STEM_Moire_GPA}\\
\bottomrule
\caption{\textbf{Traceability table: Test vs Requirements}
  \wss{Capitalize Table}}
\label{table_traceability}
\end{longtable}

\section{Prioritization}	
The resources available for the test phase of \progname{} are relatively limited and all aspects of the test plan won't be covered. Therefore, the test tasks have been prioritized by focusing first on the system tests targeting the functional requirements, then the unit tests testing the functional requirements and finally the system tests assessing the non functional requirements. The details of the prioritization are described in the following table.

\noindent 
\begin{longtable}{l p{10cm}}

\toprule
\textbf{Priority} & \textbf{Requirement tested}\\
\midrule
\endhead
P0 & \cref{ext:R_3} (\cref{aliasing-frequency-simple}), \cref{ext:R_7} (\cref{T_Phase-Extraction-No-Strain}, \cref{T_Phase-Extraction-Known-Strain}), \cref{ext:R_10} (\cref{T_constant-delta-g}, \cref{T_constant-delta-g-with-noise}) \\
P1 & \cref{ext:R_13} (\cref{T_No-2D-strain}, \cref{T_known-constant-2D-strain}, \cref{T_Bad-G_ref}, \cref{T_Bad-Delta-G}), \cref{ext:R_12}  (\cref{Test-Basic-affine-transformation}, \cref{Test-Error-q-affine-transformation}, \cref{Test-Error-pixel-affine-transformation}) \\
P2 & \cref{ext:R_7} (\cref{T_Phase-Extraction-Mask}), \cref{ext:R_10} (\cref{T_varying-delta-g}) \\
P3 & \cref{ext:R_2} (\cref{Test-Existence-SMH}, \cref{Test-Format-SMH}, \cref{Test-read-dm3-format}, \cref{Test-Existence-pixel}, \cref{Test-Format-pixel}, \cref{Test-Format-Reference}, \cref{Test-Existence-Reference}), \cref{ext:R_6}  (\cref{Test-Existence-Mask}, \cref{Test-Format-Mask}, \cref{Test-Position-Radius-Mask}), \cref{ext:R_9} (\cref{Test-Existence-U}, \cref{Test-Format-U}, \cref{Test-Position-U}) \\
P4 & \cref{ext:NR_8} (\cref{black_box_STEM_Moire_GPA}) , \cref{ext:NR_9} (\cref{black_box_STEM_Moire_GPA}) \\
P5 & \cref{ext:NR_1} (\cref{black_box_STEM_Moire_GPA-predif-Linux}, \cref{black_box_STEM_Moire_GPA-predif-Mac}, \cref{black_box_STEM_Moire_GPA-predif-Windows}), \cref{ext:NR_2} (\cref{stress_test_STEM_Moire_GPA}) \\
P6 & GUI and other lower priority tasks \\
\bottomrule
\caption{\textbf{Priority table} \wss{Capitalize Table}}
\label{priority_table}
\end{longtable}

\wss{Great work!}

\bibliography{TestPlan_biblio}
\bibliographystyle{ieeetr}

\newpage

\end{document}