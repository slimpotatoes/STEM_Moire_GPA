\documentclass[12pt, titlepage]{article}

% Author's up-front packages
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

%Packages on template
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{xr-hyper}
\usepackage{hyperref}


% ---- Author's choice to remove them ----
%\usepackage[round]{natbib}

% Author's packages

\usepackage{amsmath, mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{indentfirst}
\usepackage{float}
\usepackage{csquotes}
\usepackage{cleveref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\newcommand{\progname}{STEM Moir{\'e} GPA}
\externaldocument[ext:]{../SRS/SRS}

%Set the custom referencing system (author's initiative)
	% Goal Statement
\newtheorem{GS}{GS}
\crefname{GS}{GS}{GSs}
	% Assumption
\newtheorem{A}{A}
\crefname{A}{A}{As}
	% Theoretical Model
\newtheorem{T}{T}
\crefname{T}{T}{Ts}
	% Data Definition
\newtheorem{DD}{DD}
\crefname{DD}{DD}{DDs}
	% Data Constraints
\newtheorem{DC}{DC}
\crefname{DC}{DC}{DCs}
	% Instance Model
\newtheorem{IM}{IM}
\crefname{IM}{IM}{IMs}
	% General Definition
\newtheorem{GD}{GD}
\crefname{GD}{GD}{GDs}
	% Requirement
\newtheorem{R}{R}
\crefname{R}{R}{Rs}
	% Non Functional Requirement
\newtheorem{NR}{NR}
\crefname{NR}{NR}{NRs}
	% Likely change
\newtheorem{LC}{LC}
\crefname{LC}{LC}{LCs}



\input{../Comments}


	% Test
\newtheorem{Test}{Test}
\crefname{Test}{Test}{Tests}

\begin{document}

\title{Test Plan:\\
		STEM Moir{\'e} GPA} 
\author{Alexandre Pofelski \\
		macid: pofelska \\
		github: slimpotatoes}
\date{\today}
	
\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}
\label{symbols}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  T & Test\\
  \bottomrule
\end{tabular}\\

\wss{symbols, abbreviations or acronyms -- you can reference the SRS tables if needed}

\newpage

\tableofcontents

\listoftables

\listoffigures

\newpage

\pagenumbering{arabic}


\section{General Information}

\subsection{Purpose}

The purpose of the document is to provide the plan for testing \progname{} software. 

\subsection{Scope}

\subsection{Overview of Document}

\section{Plan}
	
\subsection{Software Description}

\progname{} software is converting STEM Moir{\'e} hologram into deformation maps. Details on the goal and the requirements of \progname{} are provided in the Problem Statement and the SRS documents. Acronyms, symbols and terminologies used in the following document are the same as the ones in the SRS document.

\subsection{Test Team}

The author is the only member of the test team.

\subsection{Automated Testing Approach}

blbabla

\subsection{Verification Tools}

\wss{Thoughts on what tools to use, such as the following: unit testing
  framework, valgrind, static analyzer, make, continuous integration, test
  coverage tool, etc.}

% \subsection{Testing Schedule}
		
% See Gantt Chart at the following url ...

\subsection{Non-Testing Based Verification}

\wss{List any approaches like code inspection, code walkthrough, symbolic
  execution etc.  Enter not applicable if that is the case.}

\section{System Test Description}
	
\subsection{Tests for Functional Requirements}
\renewcommand{\labelitemi}{$\star$}

\subsubsection{Output error characterization}
	
\paragraph{Test \cref{ext:R_3} in \cref{ext:IM_1}: Correctness of the sampling theory application when undersampling g}

\begin{Test}\normalfont\underline{Test-aliasing-frequency-simple}
\label{aliasing-frequency-simple}
\begin{itemize}
\item Type: Functional, Dynamical
\item Initial State: 
\item Input: $I_{C_{\text{ref}}}=e^{2i\pi gx}$, $p$ such that $\overrightarrow{q}=\frac{1}{p}\vec{u_x}$
\item Expected output : $\widetilde{I}_{\mathit{SHM}_{\text{sim}}}=\delta(\vec{\nu}-\vec{q})$
\item Output: ${\widetilde{I}_{\mathit{SHM}_{\text{sim}}}}^{t}$ to be tested as a Dirac delta function at $\overrightarrow{q}$
\end{itemize}
\end{Test}
		
The position in frequency space of the aliased frequency (transformation of one g from Ic to one g of IM) is key to identify the vector $\overrightarrow{q_{n,m}}$. \Cref{aliasing-frequency-simple} is designed to check if the most basic transformation when under sampling is correctly performed. More complex versions of \Cref{aliasing-frequency-simple} can be designed with reference functions having, for example, a continuous description in Fourier space. Nevertheless, the more complex tests will cover way more cases than what $I_{C_{\text{ref}}}$ typically is (a sparse function). Depending on the time availability, a more complete version of \cref{aliasing-frequency-simple} will be designed.
		
\paragraph{Test \cref{ext:R_7} in \cref{ext:IM_2}: Correctness of the GPA method application} 

\begin{Test}\normalfont\underline{Test-Phase-Extraction-No-Strain}
\label{T_Phase-Extraction-No-Strain}
\begin{itemize}
\item Type: Functional, Dynamical
\item Initial State: ?
\item Input: $I_{SMH_{exp}}=e^{2i\pi gx}$, Mask $M$ of one pixel at $g\overrightarrow{u_x}$ in $\widetilde{I}_{SMH_{exp}}$
\item Expected output $P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}=0$, $\Delta \overrightarrow{g_{j}}^{M_{exp}}=\overrightarrow{0}$, 
\item Test output:${P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}^{t}$, $\Delta {\overrightarrow{g_{j}}^{M_{exp}}}^{t}$
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r})=|{P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}^{t}(\vec{r})|$
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r})=|{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}^t(\vec{r})|$
	\end{itemize}  
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Phase-Extraction-Known-Strain}
\label{T_Phase-Extraction-Known-Strain}
\begin{itemize}
\item Type: Functional, Dynamical
\item Initial State:
\item Input: $I_{SMH_{exp}}=e^{2i\pi (g+K(x))x}$, Mask $M$ centred on $g\overrightarrow{u_x}$ in $\widetilde{I}_{SMH_{exp}}$ and with the minimum radius to include $K(x)$. 
\item Expected output $P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}=K(x)x$, $\Delta \overrightarrow{g_{j}}^{M_{exp}}=K(x)\overrightarrow{u_x}$, 
\item Test output:${P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}^{t}$, $\Delta {\overrightarrow{g_{j}}^{M_{exp}}}^{t}$
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r})=|{P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}^{t}(\vec{r})-P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}(\vec{r})|$
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r})=|{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}^t(\vec{r})-{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r})|$
	\end{itemize}  
\end{itemize}
\end{Test}				
 
\begin{Test}\normalfont\underline{Test-Phase-Extraction-Mask}
\label{T_Phase-Extraction-Mask}
\begin{itemize}
\item Type: Functional, Dynamical
\item Initial State:
\item Input: $I_{SMH_{exp}}=e^{2i\pi (g+K(x))x}$, Mask $M$ centred on $g\overrightarrow{u_x}$ in $\widetilde{I}_{SMH_{exp}}$ with different radius $\epsilon$. 
\item Expected output $P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}=K(x)x$, $\Delta \overrightarrow{g_{j}}^{M_{exp}}=K(x)\overrightarrow{u_x}$, 
\item Test output:${P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}^{t}$, $\Delta {\overrightarrow{g_{j}}^{M_{exp}}}^{t}$
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r},\epsilon)=|{P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}}^{t}(\vec{r},\epsilon)-P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}(\vec{r})|$
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r},\epsilon)=|{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}^t(\vec{r},\epsilon)-{\Delta {\overrightarrow{g_{j}}^{M_{exp}}}}(\vec{r})|$
	\end{itemize}
\end{itemize}
\end{Test}						

Because the GPA method is itself based on an approximation (see \cref{ext:IM_2} in SRS document), errors from the algorithm are added to the errors from the code. Both are probed at the same time in the tests and cannot be fully separated. \Cref{T_Phase-Extraction-No-Strain} is probing the accuracy and the precision in the most basic case possible (no strain) and is a first indicator of the \cref{ext:IM_2} performance. \cref{T_Phase-Extraction-Known-Strain} and \cref{T_Phase-Extraction-Mask} are closer to a real case scenario and highlight a more realistic version of \cref{ext:IM_2} performance. To get quantitative trends, the error will be characterized as a function of the mask properties (such as the radius) and the deformation magnitude. This characterization will allow the GPA algorithm of \progname{} to be compared with other software using the same GPA algorithm. Another interest of the performance characterization is to see a quantitative effect of the user inputs on \cref{ext:IM_2} and provide a ``good practice guidance'' in the user manual.

\paragraph{Test \cref{ext:R_10} in \cref{ext:IM_3}: Correctness of the unstrained reference calculation}	

\begin{Test}\normalfont\underline{Test-constant-delta-g}
\label{T_constant-delta-g}
\begin{itemize}
\item Type: Functional, Dynamical
\item Initial State: 
\item Input: 
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \  \Delta \overrightarrow{g}^{M_{\text{exp}}}(\vec{r})=\overrightarrow{C}$
	\item $U$ array of 1 pixel wherever on $\Delta \overrightarrow{g}^{M_{\text{exp}}}(\vec{r})$
	\item $\overrightarrow{g}^{M_{\text{exp}}}={g_x}^{M_{\text{exp}}}\overrightarrow{u_x}+{g_y}^{M_{\text{exp}}}\overrightarrow{u_y}$
	\end{itemize} 
\item Expected output: $\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}=\overrightarrow{g}^{M_{\text{exp}}}-\overrightarrow{C}$, $\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}=\overrightarrow{0}$
\item Output:${\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}^{t}$ , ${\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}^{t}$
	\begin{itemize}
	\item $E_{\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}=||{\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}^{t}-\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}||$
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}=||{\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}^{t}||$
	\end{itemize}
\end{itemize}
\end{Test}

\Cref{T_constant-delta-g} is not realistic but test the code directly. Increasing the size of U, should have absolutely no effect on the output. 

\begin{Test}\normalfont\underline{Test-constant-delta-g-with-noise}
\label{T_constant-delta-g-with-noise}
\begin{itemize}
\item Type: Functional, Dynamical
\item Initial State: 
\item Input: 
	\begin{itemize}
	\item $\overrightarrow{N}$, 2D random noise
	\item $\forall \vec{r} \in \mathbb{I}, \ \Delta \overrightarrow{g}^{M_{\text{exp}}}(\vec{r})=\overrightarrow{C} + \overrightarrow{N}$
	\item $U$ array of $n \times m$ pixels wherever on $\Delta \overrightarrow{g}^{M_{\text{exp}}}(\vec{r})$ 
	\item $\overrightarrow{g}^{M_{\text{exp}}}={g_x}^{M_{\text{exp}}}\overrightarrow{u_x}+{g_y}^{M_{\text{exp}}}\overrightarrow{u_y}$
	\end{itemize}
\item Expected output: $\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}=\overrightarrow{g}^{M_{\text{exp}}}-\overrightarrow{C}$,  $\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}=\overrightarrow{0}$
\item Output:${\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}^{t}, {\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}^{t}$
	\begin{itemize}
	\item $E_{\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}=||{\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}^{t}-\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}||$
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}=||{\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}^{t}||$
	\end{itemize}
\end{itemize}
\end{Test}

\Cref{T_constant-delta-g-with-noise} is more representative of a real case than \cref{T_constant-delta-g} and will be use to characterize the evolution of the error with respect to the level of noise and the size of U. The evaluation of $\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}$ is critical on the quantitative estimation of strain and rotation.

\begin{Test}\normalfont\underline{Test-varying-delta-g}
\label{T_varying-delta-g}
\begin{itemize}
\item Type: Functional, Dynamical
\item Initial State: 
\item Input: 
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \ \overrightarrow{g}^{M_{\text{exp}}}(\vec{r})=\overrightarrow{C}(\vec{r})$
	\item $U$ array of $n \times m$ pixels wherever on $\Delta \overrightarrow{g}^{M_{\text{exp}}}(\vec{r})$
	\item $\overrightarrow{g}^{M_{\text{exp}}}={g_x}^{M_{\text{exp}}}\overrightarrow{u_x}+{g_y}^{M_{\text{exp}}}\overrightarrow{u_y}$
\end{itemize}
\item Expected output: $\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}=\overrightarrow{g}^{M_{\text{exp}}}-F(\overrightarrow{C}(\vec{r}))$,   $\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}=\overrightarrow{C}(\vec{r})-F(\overrightarrow{C}(\vec{r}))$ where $F(\overrightarrow{C}(\vec{r}))$ is the best possible linear fit of $\overrightarrow{C}(\vec{r})$ in $U$.
\item Output:${\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}^{t}, {\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}^{t}$
	\begin{itemize}
	\item $E_{\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}=||{\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}}^{t}-\overrightarrow{g}_{\text{uns}}^{M_{\text{exp}}}||$
	\item $\forall \vec{r} \in \mathbb{I}, \ E_{\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}=||{\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}}^{t}-\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}||$
	\end{itemize}
\end{itemize}
\end{Test}

\Cref{T_varying-delta-g} might be impossible to properly interpret but the idea is to see the effect an improper choice of an unstrained reference. If a non uniform deformation field is present in the reference, \progname{} is trying to find the best linear fit to cancel it out. A solution is proposed whatever the precision of the fit. However, if the quality of the fit is poor, it could be possible that \progname{} informs/warns the user of a potential problem in the reference chosen.


\subsection{Tests for Nonfunctional Requirements}

\subsubsection{Evolution of precision with noise in \progname{}}
		
\paragraph{Test \cref{ext:NR_8} and \cref{ext:NR_9}}						

\begin{Test}\normalfont\underline{Test-Black-Box-STEM-Moir{\'e}-GPA}
\label{black_box_STEM_Moire_GPA}
\begin{itemize}
\item Type: Functional, Dynimical, Black box
\item Initial State: All user inputs are predefined ($p,M_1,M_2,U,\overrightarrow{q_{n_1,m_1}},\overrightarrow{q_{n_2,m_2}}$) except the STEM Moir{\'e} hologram
\item Input: STEM Moir{\'e} holograms with different level of noise (from no noise to high level of noise): 
	\begin{itemize}
	\item	$I_{\mathit{SMH}_\text{exp}} = I(\vec{r}) + N(\vec{r})$ with $I$ a perfect SMH (with a defined strain field $\varepsilon(\vec{r})$ and rotation field $\omega(\vec{r})$) and $N$ a random noise
	\end{itemize}
\item Expected output $\forall \vec{r} \in \mathbb{I}, \ \varepsilon(\vec{r})^{t}=\varepsilon(\vec{r}) \wedge \omega\vec({r})^{t}=\omega(\vec{r})$
\item Output:
	\begin{itemize}
	\item $\forall \vec{r} \in \mathbb{I}, \ E^{\text{\progname{}}}_{\varepsilon}=|\varepsilon(\vec{r})^{t}-\varepsilon(\vec{r})|$
	\item $\forall \vec{r} \in \mathbb{I}, \ E^{\text{\progname{}}}_{\omega}=|\omega(\vec{r})^{t}-\omega(\vec{r})|$
	\end{itemize}
\end{itemize}
\end{Test}

\Cref{black_box_STEM_Moire_GPA} looks more like a validation test than a verification test. Nevertheless, \cref{black_box_STEM_Moire_GPA} is highlighting the accuracy (with no noise), and the precision (with noise) of \progname{} seen by the end-user (code, user and algorithm errors included). The performance is then characterized as the error output function of the noise (or of the quality factor of $I_{\mathit{SMH}_{\text{exp}}}$ like the signal on noise ratio $SNR=\frac{I_{\mathit{SMH}_\text{exp}}}{N}$). The performance characterization can be used to see from which quality factor the accuracy and sensitivity of \progname{} is too poor to consider the strain and rotation results reliable and warn the user in this case. The performance graph can also be as a base of comparison with another software (if it exists) doing the same data treatment.

\subsection{Traceability Between Test Cases and Requirements}

				
\section{Unit Testing Plan}
		
\subsubsection{Input Verification test}

\paragraph{Test \cref{ext:R_2} in \cref{ext:IM_1}: Existence and Format of $I_{\mathit{SMH}_{\text{exp}}}$, $I_{C_{\text{ref}}}$ and $p$}

\begin{Test}\normalfont\underline{Test-Existence-SMH}
\begin{itemize}
\item Type: Dynamical
\item Initial State: Waiting for $I_{\mathit{SMH}_{\text{exp}}}$ user input
\item Input: $I_{\mathit{SMH}_{\text{exp}}}$ = $\emptyset$
\item Output: Error message $Err_{I_{\mathit{SMH}_{\text{exp}}}}$ should match: \enquote{No STEM Moir{\'e} hologram, please load a proper image}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Format-SMH}
\begin{itemize}
\item Type: Dynamical
\item Initial State: Waiting for $I_{\mathit{SMH}_{\text{exp}}}$ user input
\item Input: Various $I_{\mathit{SMH}_{\text{exp}}}$ improper format
\item Output: Error message $Err_{I_{\mathit{SMH}_{\text{exp}}}}$ should match: \enquote{Invalid STEM Moir{\'e} hologram format (expecting a 2D array)}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-read-dm3-format}
\begin{itemize}
\item Type: Dynamical
\item Initial State: Waiting for $I_{\mathit{SMH}_{\text{exp}}}$ or $I_{C_{\text{ref}}}$ user input
\item Input: Pre defined random 2D array in dm3 format with specific tags (calibration, microscope, high tension, ...)
\item Output: Read the tag from the dm3 file and and test each tag collected with the pre defined tags
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Existence-pixel}
\begin{itemize}
\item Type: Dynamical
\item Initial State: After importing $I_{\mathit{SMH}_{\text{exp}}}$ and format validated
\item Input: $p$=$\emptyset$
\item Output: Error message $Err_{p}$ should match: \enquote{No pixel size found}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Format-pixel}
\begin{itemize}
\item Type: Dynamical
\item Initial State: After importing $I_{\mathit{SMH}_{\text{exp}}}$ and format validated
\item Input: Improper format of $p$
\item Output: Error message $Err_{p}$ should match: \enquote{Invalid pixel size}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Format-Reference}
\begin{itemize}
\item Type: Dynamical
\item Initial State: Waiting for $I_{C_{\text{ref}}}$ user input
\item Input: Various $I_{C_{\text{ref}}}$ improper format
\item Output: Error message $Err_{I_{C_{\text{ref}}}}$ should match: \enquote{Invalid Reference image format (expecting a 2D array)}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Existence-Reference}
\begin{itemize}
\item Type: Dynamical
\item Initial State: Waiting for $I_{C_{\text{ref}}}$ user input
\item Input: $I_{C_{\text{ref}}}$ = $\emptyset$
\item Output: Error message $Err_{I_{C_{\text{ref}}}}$ should match: \enquote{No Reference image, please load a proper image}
\end{itemize}
\end{Test}


\paragraph{Test \cref{ext:R_6} in \cref{ext:IM_2}: Test of the mask user input}

\begin{Test}\normalfont\underline{Test-Existence-Mask}
\begin{itemize}
\item Type: Dynamical
\item Initial State: Waiting for $M$ user input on $\widetilde{I}_{\mathit{SMH}_{\text{exp}}}$
\item Input: $M$=$\emptyset$
\item Output:  Error message $Err_{M}$ should match: \enquote{No Mask found}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Format-Mask}
\begin{itemize}
\item Type: Dynamical
\item Initial State: Waiting for $M$ user input on $\widetilde{I}_{\mathit{SMH}_{\text{exp}}}$
\item Input: $M$ improper format (such as 1D array, 2D array out of bounds if  
\item Output:  Error message $Err_{M}$ should match: \enquote{Improper mask format}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Position-Radius-Mask}
\begin{itemize}
\item Type: Dynamical
\item Initial State: Waiting for $M$ user input on $\widetilde{I}_{\mathit{SMH}_{\text{exp}}}$
\item Input: Mask center =$(0,0)$, Mask radius=3
\item Output: Center of the circle mask positioned in the middle of the 2D array $\widetilde{I}_{\mathit{SMH}_{\text{exp}}}$ and with a radius of 3 pixels
\end{itemize}
\end{Test}

\an{Technically, the GUI should be also tested. Is the position of the pointer corresponding to the area pointed ? Is the area pointed corresponding to the center of the circle mask ? ... but it starts to get very long} 

\paragraph{Test \cref{ext:R_9} in \cref{ext:IM_3}: Test of the unstrained region user input}

\begin{Test}\normalfont\underline{Test-Existence-U}
\begin{itemize}
\item Type: Dynamical
\item Initial State: Waiting for $U$ user input on $P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}$
\item Input: $U$=$\emptyset$
\item Output:  Error message $Err_{U}$ should match: \enquote{No reference in phase image found}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Format-U}
\begin{itemize}
\item Type: Dynamical
\item Initial State: Waiting for $U$ user input on $P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}$
\item Input: $U$ improper format
\item Output:  Error message $Err_{U}$ should match: \enquote{Improper reference in phase image format}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Position-U}
\begin{itemize}
\item Type: Dynamical
\item Initial State: Waiting for $U$ user input on $P_{\Delta \overrightarrow{g_{j}}^{M_{exp}}}$
\item Input: Position left top corner=$(10,10)$, Position right bottom corner=$(30,40)$
\item Output: Rectangle center position $(20,25)$, short length $l=20$ pixels and longh length $L=30$ pixels
\end{itemize}
\end{Test}

\an{GUI should be tested again here}

\subsubsection{Output results test}

\paragraph{Test \cref{ext:R_11} in \cref{ext:IM_4}: Affine vectorial transformation}

\begin{Test}\normalfont\underline{Test-Basic-affine-transformation}
\begin{itemize}
\item Type: Functional, Dynamical
\item Initial State: 
\item Input: $\overrightarrow{q_{n,m}}=\begin{bmatrix}
1 \\
-2
\end{bmatrix}$, $\overrightarrow{g_{j}}_{\text{uns}}^{M_{\text{exp}}}=\Delta\overrightarrow{g_{j}}_{\text{cor}}^{M_{\text{exp}}}=\begin{bmatrix}
1 \\
1
\end{bmatrix}$, $p=3$
\item Output:  $\overrightarrow{g_{j}}_{\text{uns}}^{C_{\text{exp}}}=\Delta\overrightarrow{g_{j}}^{C_{\text{exp}}}=\begin{bmatrix}
4\\
-5
\end{bmatrix}$
\end{itemize}
\end{Test}

\paragraph{Test\cref{ext:R_12} in \cref{ext:IM_5}: Strain and rotation calculation}						

\begin{Test}\normalfont\underline{Test-No-2D-strain}
\label{T_No-2D-strain}
\begin{itemize}
\item Type: Functional, Dynamical
\item Initial State:
\item Input:
\begin{itemize}
	\item $G_{\text{uns}}^{\text{exp}} =
	\begin{bmatrix}
	g_{1_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} \\
	g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_y}}^{C_{\text{exp}}} 
	\end{bmatrix} =\begin{bmatrix}
	1 & 2 \\
	3 & 4 
	\end{bmatrix} $
	\item $\Delta G^{\text{exp}}(\vec{r})=
	\begin{bmatrix}
	\Delta g_{1_{x}}^{C_{\text{exp}}}(\vec{r}) & \Delta g_{1_{y}}^{C_{\text{exp}}}(\vec{r}) \\
	\Delta g_{2_{x}}^{C_{\text{exp}}}(\vec{r}) & \Delta g_{2_{y}}^{C_{\text{exp}}}(\vec{r})
	\end{bmatrix} = \begin{bmatrix}
	0 & 0 \\
	0 & 0 
	\end{bmatrix} $
	\end{itemize} 
\item Expected output:
	\begin{itemize}
	\item  $\forall \vec{r} \in \mathbb{I}, \ \varepsilon^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	\varepsilon_{\mathit{xx}^{\text{exp}}}(\vec{r}) & \varepsilon_{\mathit{xy}^{\text{exp}}}(\vec{r}) \\
	\varepsilon_{\mathit{xy}^{\text{exp}}}(\vec{r}) & \varepsilon_{\mathit{yy^{\text{exp}}}}(\vec{r})
	\end{bmatrix} = \begin{bmatrix}
	0 & 0 \\
	0 & 0 
	\end{bmatrix} $
	\item $\forall \vec{r} \in \mathbb{I}, \  \omega^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & \omega_{\mathit{xy}^{\text{exp}}}(\vec{r}) \\
	-\omega_{\mathit{xy}^{\text{exp}}}(\vec{r}) & 0 
	\end{bmatrix} = \begin{bmatrix}
	0 & 0 \\
	0 & 0 
	\end{bmatrix} $
	\end{itemize}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-known-constant-2D-strain}
\label{T_known-constant-2D-strain}
\begin{itemize}
\item Type: Functional, Dynamical
\item Initial State:
\item Input:
\begin{itemize}
	\item $G_{\text{uns}}^{\text{exp}} =
	\begin{bmatrix}
	g_{1_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} \\
	g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_y}}^{C_{\text{exp}}} 
	\end{bmatrix} =\begin{bmatrix}
	1 & 0 \\
	0 & 1 
	\end{bmatrix}$
	\item Various $\Delta G^{\text{exp}}(\vec{r}) =
	\begin{bmatrix}
	\Delta g_{1_{x}}^{C_{\text{exp}}}(\vec{r}) & \Delta g_{1_{y}}^{C_{\text{exp}}}(\vec{r}) \\
	\Delta g_{2_{x}}^{C_{\text{exp}}}(\vec{r}) & \Delta g_{2_{y}}^{C_{\text{exp}}}(\vec{r})
	\end{bmatrix}$
		\begin{itemize}
		\item Uniaxial strain along $\vec{u_x}$, $\Delta G^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0.1 & 0 \\
	0 & 0 
	\end{bmatrix} $
		\item Uniaxial strain along $\vec{u_y}$, $\Delta G^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0 \\
	0 & 0.1 
	\end{bmatrix} $
		\item Pure shear strain, $\Delta G^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0.1 \\
	0.1 & 0 
	\end{bmatrix} $
		\item Pure rotation, $\Delta G^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0.1 \\
	-0.1 & 0 
	\end{bmatrix} $
		\end{itemize}	
	
\end{itemize} 
\item Expected output:
	\begin{itemize}
	\item Uniaxial strain along $\vec{u_x}$,\\
	\newline
	$\begin{cases} 
	\forall \vec{r} \in \mathbb{I}, \ \varepsilon^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	-\frac{1}{11} & 0 \\
	0 & 0
	\end{bmatrix}  \\
	\forall \vec{r} \in \mathbb{I}, \  \omega^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0 \\
	0 & 0 
	\end{bmatrix} 
	\end{cases}$
	\item Uniaxial strain along $\vec{u_y}$,\\
	\newline
	$\begin{cases} 
	\forall \vec{r} \in \mathbb{I}, \ \varepsilon^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0 \\
	0 & -\frac{1}{11}
	\end{bmatrix}  \\
	\forall \vec{r} \in \mathbb{I}, \  \omega^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0 \\
	0 & 0 
	\end{bmatrix} 
	\end{cases}$
	\item Pure shear strain,\\
	\newline
	$\begin{cases} 
	\forall \vec{r} \in \mathbb{I}, \ \varepsilon^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & -\frac{1}{11} \\
	-\frac{1}{11} & 0
	\end{bmatrix}  \\
	\forall \vec{r} \in \mathbb{I}, \  \omega^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0 \\
	0 & 0 
	\end{bmatrix} 
	\end{cases}$
	\item Pure rotation,\\
	\newline
	$\begin{cases} 
	\forall \vec{r} \in \mathbb{I}, \ \varepsilon^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & 0 \\
	0 & 0
	\end{bmatrix}  \\
	\forall \vec{r} \in \mathbb{I}, \  \omega^{\text{exp}}(\vec{r}) = \begin{bmatrix}
	0 & \frac{1}{11} \\
	-\frac{1}{11} & 0 
	\end{bmatrix} 
	\end{cases}$
	\end{itemize}

\item Output:  ${\varepsilon^{\text{exp}}(\vec{r})}^{t}-\varepsilon^{\text{exp}}(\vec{r}), {\omega^{\text{exp}}(\vec{r})}^{t}- \omega^{\text{exp}}(\vec{r})$  and test them to be 0

The special case with $det(G_{\text{uns}}^{\text{exp}}+\Delta G^{\text{exp}})=0$ should be also tested.
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Improper-$\Delta G^{\text{exp}}$}
\label{T_Bad-G_ref}
\begin{itemize}
\item Type: Functional, Dynamical
\item Initial State: Whatever $\Delta G^{\text{exp}}(\vec{r})$
\item Input:
\begin{itemize}
	\item $G_{\text{uns}}^{\text{exp}} =
	\begin{bmatrix}
	g_{1_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} \\
	g_{2_{{\text{uns}}_x}}^{C_{\text{exp}}} & g_{2_{{\text{uns}}_y}}^{C_{\text{exp}}} 
	\end{bmatrix} =\begin{bmatrix}
	1 & 1 \\
	1 & 1 
	\end{bmatrix} $
	\end{itemize} 
\item Output:
Error message $Err_{G_{\text{uns}}^{\text{exp}}}$ should match: \enquote{Matrix $G_{\text{uns}}^{\text{exp}}$ non invertible, the crystalline wave vectors are liked (collinear). Please chose another combination of crystalline wave vectors.}
\end{itemize}
\end{Test}

\begin{Test}\normalfont\underline{Test-Improper-$G_{\text{uns}}^{\text{exp}}$}
\label{T_Bad-Delta-G}
\begin{itemize}
\item Type: Functional, Dynamical
\item Initial State: 
\item Input:
\begin{itemize}
	\item $\Delta G^{\text{exp}}+G_{\text{uns}}^{\text{exp}} =
	\begin{bmatrix}
	1 & 1 \\
	1 & 1 
	\end{bmatrix} $
	\end{itemize} 
\item Output:
Error message $Err_{\Delta G^{\text{exp}}}$ should match: \enquote{Matrix $G^{\text{exp}}$ non invertible. If  $G_{\text{uns}}^{\text{exp}}$ is invertible, something is probably wrong with $\Delta G^{\text{exp}}$.}
\end{itemize}
\end{Test}
					

\bibliography{TestPlan_biblio}
\bibliographystyle{ieeetr}

\newpage

\section{Appendix}

This is where you can place additional information.

\subsection{Symbolic Parameters}

The definition of the test cases will call for SYMBOLIC\_CONSTANTS.
Their values are defined in this section for easy maintenance.

\subsection{Usability Survey Questions?}

This is a section that would be appropriate for some teams.

\end{document}